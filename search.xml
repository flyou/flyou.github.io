<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[微信扫一扫揭秘]]></title>
      <url>http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要探索二维码的秘密之前，我们首先需要简单了解下什么是二维码。</p>
<h3 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h3><blockquote>
<p>二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</p>
</blockquote>
<p>其实简单的说二维码就是一段简单的字符串图形化的展示，它可能是一个url，一段文字，或者是一首唐诗也不错哦<br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rxxbqqnsj207s07sgmr.jpg" alt="二维码1"><br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7rxyajt8nj207s07sjrt.jpg" alt="二维码2"><br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7rxz0bdixj207s07s75b.jpg" alt="二维码3"></p>
<h3 id="为什么要使用二维码"><a href="#为什么要使用二维码" class="headerlink" title="为什么要使用二维码"></a>为什么要使用二维码</h3><p>二维码的诞生可以说是真正的促进这移动互联网的发展。</p>
<ul>
<li>信息获取（名片、地图、WIFI密码、资料）</li>
<li>网站跳转（跳转到微博、手机网站、网站）</li>
<li>广告推送（用户扫码，直接浏览商家推送的视频、音频广告）</li>
<li>手机电商（用户扫码、手机直接购物下单）</li>
<li>防伪溯源（用户扫码、即可查看生产地；同时后台可以获取最终消费地)</li>
<li>优惠促销（用户扫码，下载电子优惠券，抽奖）</li>
<li>会员管理（用户手机上获取电子会员信息、VIP服务）</li>
<li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付）</li>
</ul>
<p>在不同的领域，不同的行业二维码都可以用来简化原来的工作流程，那么我们为什么不来试试二维码呢？</p>
<h3 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h3><p>通过对上面的了解相信大家对二维码已经有了一定的了解，那么二维码是怎么生成的呢?</p>
<blockquote>
<p>维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x<br>25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)<em>4 + 21（V是版本号） 最高Version<br>40，(40-1)</em>4+21 = 177，所以最高是177 x 177 的正方形。      </p>
</blockquote>
<p><strong>二维码的基本结构如下：</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7rz07e9bhj20le0cuaax.jpg" alt=""></p>
<p>二维码一般由定位点图案、功能性数据、数据码和纠错码组成，生成的算法是固定的有需要的同学可以了解<br><a href="https://my.oschina.net/DeanCTO/blog/205677" title="二维码的生成原理" target="_blank" rel="external">二维码的生成原理</a>、<br><a href="http://blog.csdn.net/kelindame/article/details/45155185" title="二维码生成原理解析" target="_blank" rel="external">二维码生成原理解析</a><br>如今，基本上各个语言都有了比较好的二维码生成与解码的开源项目，有需要的同学可以自行google，本次我们呢不做具体介绍，因为不是重点啊 。</p>
<h2 id="微信二维码揭秘"><a href="#微信二维码揭秘" class="headerlink" title="微信二维码揭秘"></a>微信二维码揭秘</h2><h3 id="微信的二维码有哪些"><a href="#微信的二维码有哪些" class="headerlink" title="微信的二维码有哪些"></a>微信的二维码有哪些</h3><p>在平时的使用中我们可以发现微信在很多的场景中都有二维码的使用在，名片，联系人，支付等尤为明显，可以说二维码已经成为微信不可或缺的设计呢功能了。<br>那么微信的二维码到底有哪些是呢？</p>
<p><strong>以二维码扫描结果和功能区分</strong></p>
<ol>
<li>http(s)://www.<em>*</em>.com http链接</li>
<li>weixin://qr/××× 微信二维码</li>
<li><a href="http://weixin.qq.com/r/×××" target="_blank" rel="external">http://weixin.qq.com/r/×××</a> 微信二维码名片</li>
<li><a href="https://login.weixin.qq.com/l/×××" target="_blank" rel="external">https://login.weixin.qq.com/l/×××</a> 网页登陆二维码</li>
<li><a href="https://login.wechatapp.com/l/×××" target="_blank" rel="external">https://login.wechatapp.com/l/×××</a> 国际部网页登陆二维码</li>
<li>weixin://wxpay/bizpayurl/××× 微信支付</li>
<li><a href="http://weixin.qq.com/g/×××" target="_blank" rel="external">http://weixin.qq.com/g/×××</a> 微信群二维码</li>
</ol>
<p>其实在上面的二维码例子中大体上可以分为两类，1，4，5未一类，其他的为一类。第一类主要是普通类型和涉及登录相关的逻辑，第二类中的逻辑就是我们本次要谈论的逻辑。</p>
<p><strong>第二类流程如下：</strong><br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rypqmgpjj20uk061js1.jpg" alt="流程图"></p>
<h3 id="实现微信二维码逻辑"><a href="#实现微信二维码逻辑" class="headerlink" title="实现微信二维码逻辑"></a>实现微信二维码逻辑</h3><p>由上面的介绍我们很清楚的知道，我们想要实现上面的功能我们生成的二维码肯定是一个url，然后对本本地是否安装有app的判断也是在服务端实现的（其实就是个js而已，不要怕），当然在客户端也需要对自己的代码做相应的配置。</p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>由于本人系Android开发工程师，对ios的了解也不是太多，所以本次配置主要是对android端而言的。<br>首先在manifest文件中配置扫描后需要跳转activity的intent-filter</p>
<p>还需要制定对应的host、pathPrefix、scheme<br>至于host、pathPrefix、scheme是什么，大家可以自己去google下，其实只要了解Url的组成原理就ok了。</p>
<pre><code>&lt;activity android:name=&quot;.otherTest.scan.FromUrlActicity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
            &lt;data
                android:host=&quot;www&quot;
                android:pathPrefix=&quot;/com/test&quot;
                android:scheme=&quot;flyou&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><p>上面的host和 pathPrefix是可以省略的，不过还是推荐大家都写上。<br>这样客户端的配置就完成了。        </p>
<h4 id="服务端解析"><a href="#服务端解析" class="headerlink" title="服务端解析"></a>服务端解析</h4><p>首先根据浏览器的userAgent判断来自哪个终端，如果是PC则直接跳转到下载页，如果是Android或者Ios则判断本地判断本地app书否存在如果存在则根据定义的scheme打开相应页面并传递数据，如果不存在该app则跳转到下载页面。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;我是一个测试页面&lt;/title&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=320.1, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

&lt;script&gt;
/*获取自定义数据*/
function getQueryString(name) {  
    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);  
    var r = window.location.search.substr(1).match(reg);  
    if (r != null) return unescape(r[2]);  
    return null;  
}  
var userId=getQueryString(&quot;userId&quot;);
var u = navigator.userAgent || &apos;&apos;;
 /*首先判断是否是pc，若是pc访问则跳转到http://flyou.ren/ */
var isPC = !/(iphone|ios|android|mini|mobile|mobi|Nokia|Symbian|iPod|iPad|Windows\s+Phone|MQQBrowser|wp7|wp8|UCBrowser7|UCWEB|360\s+Aphone\s+Browser)/i.test(u);
var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //android终端或者uc浏览器
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if (isPC) { location.href = &quot;http://flyou.ren/&quot;; }
else if (isAndroid) {
    var the_href=&quot;http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98&quot;;//获得下载链接或在app下载页
    location.href=&quot;flyou://www/com/test?userId=&quot;+userId;//打开某手机上的某个app应用，并传递参数
    setTimeout(function(){
        window.location=the_href;//如果超时就跳转到app下载页，或者直接下载
    },2000);
}
else{
    //服务端可以根据ios 先关逻辑做相应的判断
    alert(&apos;宝宝暂时还不持支持IOS操作系统，宝宝会努力的&apos;)
}

&lt;/script&gt;


&lt;/head&gt;

&lt;/html&gt;
</code></pre><h4 id="服务端返回数据处理"><a href="#服务端返回数据处理" class="headerlink" title="服务端返回数据处理"></a>服务端返回数据处理</h4><p>在对应的Acticity里处理传递回来的参数，并做相应的处理，如微信名片二维码的功能，返回给相应页面用户id，当然这个用户的userId可以是经过加密的（别我问我怎么加密，你们这么加密我也不想知道）。</p>
<pre><code>public class FromUrlActicity extends AppCompatActivity {

private TextView tvUserid;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_qrcode_acticity);
    tvUserid = (TextView) findViewById(R.id.userid);
    Uri uriData = this.getIntent().getData();
    String userId = uriData.getQueryParameter(&quot;userId&quot;);

    tvUserid.setText(&quot;我是来自服务器的UserId:&quot;+userId);

    }
}
</code></pre><h4 id="扫描二维码"><a href="#扫描二维码" class="headerlink" title="扫描二维码"></a>扫描二维码</h4><p>自己或者使用第三方工具生成二维码如下</p>
<p><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s0hmygplj207s07s752.jpg" alt=""></p>
<p><strong>二维码对应字符串：http:\henu.flyou.ren/scan?userId=553274238</strong></p>
<p>在手机上使用浏览器扫一扫扫描二维码即可进入如下界面，并获得服务端传来的参数，完成相应的逻辑<br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s01h4fndj20u00fwwfz.jpg" alt=""></p>
<p>当然，二维码可以向服务器传递多个数据，服务器也可以向客户端返回多个数据，分别定义获取即可。明白了上述的流程想要实现微信的上述流程也是很容易的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，二维码的功能并不仅仅局限于上面的逻辑，二维码可以应用在多个行业和领域，那么快快发动你的才智来发现新的大陆吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于截图你所要了解的一切]]></title>
      <url>http://flyou.ren/2016/09/12/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%9B%BE%E4%BD%A0%E6%89%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着为什么要使用截图功能？</p>
<ul>
<li>更方便记录</li>
<li>更加便于分享</li>
<li>更加利于传输</li>
</ul>
<p>在android上有哪些截屏的方法呢？</p>
<ol>
<li>使用adb工具进行截图</li>
<li>使用android系统自带的截图</li>
<li>在自己的应用中实现截图操作</li>
</ol>
<p>今天，就对以上三种截图的方式进行下分析，写的不好的地方还请大家指正，共同进步。</p>
<p>##截图的实现</p>
<h3 id="1-使用adb命令截图"><a href="#1-使用adb命令截图" class="headerlink" title="1.使用adb命令截图"></a>1.使用adb命令截图</h3><p>系统是Android 2.3以上：</p>
<p><code>adb shell screencap -p xxx.png</code></p>
<p>系统是Android 4.0以上：</p>
<p><code>adb shell screenshot xxx.png</code></p>
<p>那么上面两个有什么区别呢？</p>
<p>screencap是从Android 2.3开始提供的一个系统级的截图工具，通过源码可以了解到screencap的实现方式，默认会从底层UI Surface去获取屏幕截图，如果失败则从linux kernel层的display framebuffer(/dev/graphics/fb0)去获取屏幕截图。</p>
<p>screenshot是从Android 4.0开始提供的另一个截图的工具， 通过源码可以发现screenshot则是直接读取/dev/graphics/fb0去获取屏幕的图像数据。</p>
<p>明白了这个，你就会清楚哪些电脑上的豌豆荚、腾讯手机管家等软件的屏幕截图功能是如何实现的了，其实就是调用这个这个api然后读取本地的图片而已。</p>
<pre><code>adb shell screencap -p /sdcard/flyou.png
adb pull /mnt/sdcard/output.png D:flyou.png
adb shell rm /sdcard/flyou.png
</code></pre><p>首先是调用系统截图命令将图片保存到sd卡下，然后调用adb pull将sd卡上的截图给拉出，最后删除本地文件。</p>
<p>需要注意的是，上面的命令在电脑上操作adb命令进行截图，手机是不需要root权限的，但是如果在手机上在手机上是需要的。</p>
<pre><code>public void shortScreen(String filepath){
Process process = null;
try{
process = Runtime.getRuntime().exec(&quot;su&quot;);
PrintStream outputStream = null;
try {
    outputStream = new PrintStream(new BufferedOutputStream(process.getOutputStream(), 8192));
    outputStream.println(&quot;screencap -p &quot; + filePath);
    outputStream.flush();
}catch(Exception e){
    Log.e(TAG, e);
} finally {
    if (outputStream != null) {
        outputStream.close();
    }
}
process.waitFor();
}catch(Exception e){
Log.e(TAG, e);
}finally {
if(process != null){
    process.destroy();
}
}
}
</code></pre><p>在手机端需要执行如上代码便可执行adb命令截图。<br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7qvwenwrkj20o50c2n04.jpg" alt=""></p>
<h3 id="2-使用android系统自带的截图"><a href="#2-使用android系统自带的截图" class="headerlink" title="2.使用android系统自带的截图"></a>2.使用android系统自带的截图</h3><p>在android系统中，大多数的截屏快捷键都是“音量-” 加上电源键实现的，当然也有一些特殊的机型是不一样的。</p>
<p>虽然，我们不能在开发中这个使用这个api，但是我们可以通过源码来看看它是如何是实现的。</p>
<p>Android源码中对按键的捕获位于文件PhoneWindowManager.java（alps\frameworks\base\policy\src\com\android\internal\policy\impl）中，这个类处理所有的键盘输入事件，其中函数interceptKeyBeforeQueueing（）会对常用的按键做特殊处理。以nexus5 和小米5为例，是同时按电源键和音量下键来截屏，那么在这个函数中我们会看到这么两段代码：</p>
<pre><code>.......
 case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE: {
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (isScreenOn &amp;&amp; !mVolumeDownKeyTriggered
                            &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                        mVolumeDownKeyTriggered = true;
                        mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
......

        case KeyEvent.KEYCODE_POWER: {
            result &amp;= ~ACTION_PASS_TO_USER;
            if (down) {
                if (isScreenOn &amp;&amp; !mPowerKeyTriggered
                        &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                    mPowerKeyTriggered = true;
                    mPowerKeyTime = event.getDownTime();
                    interceptScreenshotChord();
                }
......

//以下代码是对按键处理的判断
 private void interceptScreenshotChord() {
    if (mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; !mVolumeUpKeyTriggered) {
        final long now = SystemClock.uptimeMillis();
        if (now &lt;= mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS
                &amp;&amp; now &lt;= mPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) {
            mVolumeDownKeyConsumedByScreenshotChord = true;
            cancelPendingPowerKeyAction();

            mHandler.postDelayed(mScreenshotChordLongPress,
                        ViewConfiguration.getGlobalActionKeyTimeout());
        }
    }
}
</code></pre><p>系统截图的实现：</p>
<pre><code>private final Runnable mScreenshotChordLongPress = new Runnable() {
    public void run() {
        takeScreenshot();
    }
};

//如下为takeScreenshot()的代码
private void takeScreenshot() {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;,
                &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw())
                        msg.arg1 = 1;
                    if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw())
                        msg.arg2 = 1;
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    }
                }
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {}
        };
        if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
</code></pre><p>可以看到这个函数使用AIDL绑定了service服务到”com.android.systemui.screenshot.TakeScreenshotService”，并处理子线程返回的截图结果。</p>
<p>PS：android系统内部真的有好多实现都是靠的handler和message</p>
<pre><code>public class TakeScreenshotService extends Service {
private static final String TAG = &quot;TakeScreenshotService&quot;;

private static GlobalScreenshot mScreenshot;

private Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                final Messenger callback = msg.replyTo;
                if (mScreenshot == null) {
                    mScreenshot = new GlobalScreenshot(TakeScreenshotService.this);
                }
                mScreenshot.takeScreenshot(new Runnable() {
                    @Override public void run() {
                        Message reply = Message.obtain(null, 1);
                        try {
                            callback.send(reply);
                        } catch (RemoteException e) {
                        }
                    }
                }, msg.arg1 &gt; 0, msg.arg2 &gt; 0);
        }
    }
};

@Override
public IBinder onBind(Intent intent) {
    return new Messenger(mHandler).getBinder();
}
}
</code></pre><p>最终调用，takeScreenshot获取屏幕截图</p>
<pre><code>/**
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) {
    // We need to orient the screenshot correctly (and the Surface api seems to take screenshots
    // only in the natural orientation of the device :!)
    mDisplay.getRealMetrics(mDisplayMetrics);
    float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};
    float degrees = getDegreesForRotation(mDisplay.getRotation());
    boolean requiresRotation = (degrees &gt; 0);
    if (requiresRotation) {
        // Get the dimensions of the device in its native orientation
        mDisplayMatrix.reset();
        mDisplayMatrix.preRotate(-degrees);
        mDisplayMatrix.mapPoints(dims);
        dims[0] = Math.abs(dims[0]);
        dims[1] = Math.abs(dims[1]);
    }

    // Take the screenshot
    mScreenBitmap = Surface.screenshot((int) dims[0], (int) dims[1]);
    if (mScreenBitmap == null) {
        notifyScreenshotError(mContext, mNotificationManager);
        finisher.run();
        return;
    }

    if (requiresRotation) {
        // Rotate the screenshot to the current orientation
        Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(ss);
        c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
        c.rotate(degrees);
        c.translate(-dims[0] / 2, -dims[1] / 2);
        c.drawBitmap(mScreenBitmap, 0, 0, null);
        c.setBitmap(null);
        mScreenBitmap = ss;
    }

    // Optimizations
    mScreenBitmap.setHasAlpha(false);
    mScreenBitmap.prepareToDraw();

    // Start the post-screenshot animation
    startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,
            statusBarVisible, navBarVisible);
}
</code></pre><p>最终得到Surface.screenshot（）方法，该方法属于native 层的方法，我们已经无法对代码进行查看，但是通过该方法</p>
<pre><code>public static native Bitmap screenshot(int width, int height);
</code></pre><p>我们可以看出，底层实际上是接受了一个图片的宽高，最终给我们返回一个半成品的bitmap，然后在java层我们再对图片进行一系列的操作。</p>
<h3 id="3-在自己的应用中实现截图操作"><a href="#3-在自己的应用中实现截图操作" class="headerlink" title="3.在自己的应用中实现截图操作"></a>3.在自己的应用中实现截图操作</h3><p>上面说了好多应用之外截图方式的实现，那么如果我们想要在我们的app中实现截图功能，我们该如何实现呢？</p>
<pre><code>public class ScreenShot {   

// 获取指定Activity的截屏，保存到png文件   
private static Bitmap takeScreenShot(Activity activity，String fileName){   


//View是你需要截图的View   
View view = activity.getWindow().getDecorView();   
view.setDrawingCacheEnabled(true);   
view.buildDrawingCache();   
Bitmap b1 = view.getDrawingCache();  
view.destroyDrawingCache();   
savePic(b1,fileName)
}   


//保存到sdcard   
private static void savePic(Bitmap b,String strFileName){   
FileOutputStream fos = null;   
try {   
fos = new FileOutputStream(strFileName);   
if (null != fos)   
{   
b.compress(Bitmap.CompressFormat.PNG, 90, fos);   
fos.flush();   
fos.close();   
}   
} catch (FileNotFoundException e) {   
e.printStackTrace();   
} catch (IOException e) {   
e.printStackTrace();   
}   
}   
}  
</code></pre><p><strong>截图效果如下：</strong><br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxsmer3gj20u01hcjvv.jpg" alt=""></p>
<p>如果不想要状态栏只需要对获得bitmap进行操作，截去状态栏的高度即可</p>
<p><strong>相关代码如下：</strong></p>
<pre><code>//获取状态栏高度   
Rect frame = new Rect();   
activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);   
int statusBarHeight = frame.top;   
System.out.println(statusBarHeight);   

//获取屏幕长和高   
int width = activity.getWindowManager().getDefaultDisplay().getWidth();   
int height = activity.getWindowManager().getDefaultDisplay().getHeight();   


//去掉标题栏    
Bitmap newBitmap = Bitmap.createBitmap(b1, 0, statusBarHeight, width, height - statusBarHeight); 
</code></pre><p>这样就可以获取对应没有状态栏的图片。<br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxz0kw8uj20u01f9430.jpg" alt=""><br>但是，这样往往不能满足我们在开发中的需求，往往在开发中产品会要求我们只截去内容部分的图片，那么这时我们该怎么做呢？</p>
<p>其实方法也是很多，比如对<strong>先截去屏幕，然后对制定区域进行裁剪</strong>，<strong>使用自定义控件</strong>，其实原理也很简单，先绘制背景在确定子View的位置，再回执子View即可。但是呢这里也有几个比较简单的方法，<strong>直接获取相应布局的父布局，然后调用相关方法进行截取并保存即可</strong>。</p>
<p>下面只给出第三种方式的实现方法，如果对上面两种实现方法感兴趣的话自己可以了解下。</p>
<pre><code>View view = findViewById(R.id.share_layout);
Bitmap bmp = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
view.draw(new Canvas(bmp));
</code></pre><p>此时取到的BitMap就是你的目标布局的图片，但是使用此方法必须在数据加载完毕后使用，不然获取的截图可能是空白的，还有bitmap使用完需要记得<strong>recycle</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rog43thzj20p011iad9.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实现屏幕截图的方法有很多，实现的方法也是多种多样的，希望大家根据自己的需要都能够找到适合自己的方法，如果写的有什么纰漏的地方，欢迎大家指正讨论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定下几个小目标]]></title>
      <url>http://flyou.ren/2016/09/05/%E5%AE%9A%E4%B8%8B%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7iqwwww7yj20h809kdgu.jpg" alt=""></p>
<p>转眼已经毕业整整三个月了，一直没有好好静下来写些东西了，最近看见朋友圈都在定目标，再加上今天有空所以就也写点东西吧。</p>
<h3 id="1-瘦下来"><a href="#1-瘦下来" class="headerlink" title="1.瘦下来"></a>1.瘦下来</h3><p>自己真的是越来越胖了，自己都受不了自己了，已经从以前的120飙升到了160，哦买噶，再不瘦我真的就要变成胖子了，我不要，我不要！！</p>
<p>从今天起，每天坚持锻炼，晚上少吃点可好？当然120不是我的目标体重，要不然又要被老妈催着增肥了！！那么就140吧？</p>
<h3 id="2-沉下去"><a href="#2-沉下去" class="headerlink" title="2.沉下去"></a>2.沉下去</h3><p>毕业是毕业了，但是我认为我们都不能因为自己角色的改变而去中断学习，学习应该是贯穿每个人一生的事情。我还是希望自己能够把自己定位为一个学生，对啊学生真好。</p>
<ul>
<li>在最近的一段时间尽量把java基础和数据库操作回顾一遍</li>
<li>学习前端以及node.js相关知识，如果可以的话尽量多看看PHP吧</li>
<li>掌握几门其他语言，python和lua等</li>
<li>至于android，我还是希望自己能多学习，多记录</li>
</ul>
<h3 id="3-来写作"><a href="#3-来写作" class="headerlink" title="3.来写作"></a>3.来写作</h3><p>写作可以让我们更加巩固自己的知识，是自己的知识体系更加的清晰并完善，只有不断的写作和记录自己才会知道自己还有那些不了解，自己还有那些需要去学习。</p>
<p>当然，我觉得我平时也不会仅仅去写些关于技术的相关的，我更会在自己的博客中分享自己的心得以及对某一件事的看法，因为写作也是使人放松的一种方法，那么我们为什么不坚持呢？</p>
<h3 id="4-去旅游"><a href="#4-去旅游" class="headerlink" title="4.去旅游"></a>4.去旅游</h3><p>2016年已经过去了一大半，说好的出玩计划因为各种原因都没有实现，最近心里也是有许多的额事情，感觉心得压力很大，真的觉得自己必须要出去转转了，至于目的地是哪，我觉得都是可以的，厦门？杭州？南京？或者是西藏吧。</p>
<p>一个人或者约三两个好友感觉去哪里都是不错的，是的，是时候出去转转了呢！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，我的小目标定好了，希望自己的目标能够在新年前实现吧，这样我才好写我的年终总结啊。</p>
<p>于：2016/9/5 15:59:15 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android夜间模式浅析]]></title>
      <url>http://flyou.ren/2016/08/18/android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="几种实现夜间模式的方式"><a href="#几种实现夜间模式的方式" class="headerlink" title="几种实现夜间模式的方式"></a>几种实现夜间模式的方式</h2><h3 id="1：修改theme，重启activity"><a href="#1：修改theme，重启activity" class="headerlink" title="1：修改theme，重启activity"></a>1：修改theme，重启activity</h3><p>使用时定义不同的主题，通过切换主题重启acticity的方式完成切换</p>
<p><strong>优点</strong>：正儿八经的夜间模式，配色看着舒服</p>
<p><strong>缺点</strong>：图片刺眼、闪屏</p>
<h3 id="2：覆盖一定透明度的View"><a href="#2：覆盖一定透明度的View" class="headerlink" title="2：覆盖一定透明度的View"></a>2：覆盖一定透明度的View</h3><p>使用一个带黑色带透明度的View，盖在现有的activity上，效果类似你带上墨镜，看着太阳不刺眼。</p>
<p><strong>优点</strong>：不用重启activity，不闪屏；加上透明度过渡动画，模式之间切换非常舒服，解决了1中，白底图片依旧刺眼的问题。</p>
<p><strong>缺点</strong>：配色没变化，就算带上墨镜，白天依旧是白天。</p>
<h3 id="3：使用动态换肤方案"><a href="#3：使用动态换肤方案" class="headerlink" title="3：使用动态换肤方案"></a>3：使用动态换肤方案</h3><p>一般借助于第三方库完成换肤，如：<br><a href="https://github.com/hongyangAndroid/ChangeSkin" target="_blank" rel="external">https://github.com/hongyangAndroid/ChangeSkin</a><br><a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">https://github.com/fengjundev/Android-Skin-Loader</a></p>
<p><strong>优点</strong>：不用重启activity，不闪屏；可以为程序提供多种皮肤方案不局限于夜间/白天模式。</p>
<p><strong>缺点</strong>：在制作方面代价过大，侵入性较强，需要以来第三方库完成，可靠性不能得到保证。</p>
<h3 id="4：使用-Support-Library-23-2-0-DayNight主题实现"><a href="#4：使用-Support-Library-23-2-0-DayNight主题实现" class="headerlink" title="4：使用 Support Library 23.2.0 DayNight主题实现"></a>4：使用 Support Library 23.2.0 DayNight主题实现</h3><p><strong>优点</strong>：Google自家产品，可靠性高，配置简单，省心省力，在仅仅需要实现夜间/日间模式的应用内强烈推荐。</p>
<p><strong>缺点</strong>：不支持多皮肤切换算吗？貌似今天只谈夜间模式的实现……。</p>
<h2 id="使用DayNight主题来实现夜间模式"><a href="#使用DayNight主题来实现夜间模式" class="headerlink" title="使用DayNight主题来实现夜间模式"></a>使用DayNight主题来实现夜间模式</h2><p>对于前两种方式来说，从实现来说是不困难的但是对用户的体验在一定程度上是很不好的，一个需要重启activity，一个配色无法改变都是我们不推荐的。</p>
<p>当然第三种方式市面上也有比较成熟的第三方库来完成程序的换肤，但是对于单单需要夜间模式的应用来说未免有些大材小用了。</p>
<p>今天我们使用DayNight主题来实现换肤功能。</p>
<h3 id="1-定义DayNight主题，及相关属性"><a href="#1-定义DayNight主题，及相关属性" class="headerlink" title="1.定义DayNight主题，及相关属性"></a>1.定义DayNight主题，及相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;</div><div class="line">      &lt;!-- Customize your theme here. --&gt;</div><div class="line">      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</div><div class="line"> 		&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>可以在主题中定义一些颜色尺寸等属性，在vlaues的colors.xml 声明color属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>在res下面创建values-night文件夹，创建colors.xml声明color属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#1f2023&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#18181a&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<h3 id="2-为程序设置初始模式"><a href="#2-为程序设置初始模式" class="headerlink" title="2.为程序设置初始模式"></a>2.为程序设置初始模式</h3><p>程序中进行主题的初始化。你需要调用 AppCompatDelegate.setDefaultNightMode() ，它有四个参数：</p>
<p>MODE_NIGHT_NO. 使用亮色（light）主题</p>
<p>MODE_NIGHT_YES. 使用暗色（dark）主题</p>
<p>MODE_NIGHT_AUTO. 根据当前时间自动切换 亮色（light）/暗色（dark）主题</p>
<p>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统，通常为 MODE_NIGHT_NO</p>
<p>如在Application中进行初始化：</p>
<pre><code>public class MyApplication extends Application {
static {
    AppCompatDelegate.setDefaultNightMode(
            AppCompatDelegate.MODE_NIGHT_NO);
}

@Override
public void onCreate() {
    super.onCreate();
}

}
</code></pre><h3 id="3-在初始化时就切换夜间模式"><a href="#3-在初始化时就切换夜间模式" class="headerlink" title="3.在初始化时就切换夜间模式"></a>3.在初始化时就切换夜间模式</h3><pre><code> public class MyActivity extends AppCompatActivity {
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
        // Set the local night mode to some value
        getDelegate().setLocalNightMode(
                AppCompatDelegate.MODE_NIGHT_...);
        // 调用 recreate() 使设置生效
        recreate();
    }
} }
</code></pre><h3 id="4-如何获取当前主题的状态"><a href="#4-如何获取当前主题的状态" class="headerlink" title="4.如何获取当前主题的状态"></a>4.如何获取当前主题的状态</h3><pre><code>int currentNightMode = getResources().getConfiguration().uiMode
    &amp; Configuration.UI_MODE_NIGHT_MASK;

case Configuration.UI_MODE_NIGHT_NO:

case Configuration.UI_MODE_NIGHT_YES:

case Configuration.UI_MODE_NIGHT_UNDEFINED:
</code></pre><p>可以通过上面面的几种状态来进行相应的操作如：<br>```<br> private void judeStatusOfDayNight() {</p>
<pre><code>    int currentNightMode = getResources().getConfiguration().uiMode
            &amp; Configuration.UI_MODE_NIGHT_MASK;
    switch (currentNightMode) {
        case Configuration.UI_MODE_NIGHT_NO:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_YES);


            break;
        case Configuration.UI_MODE_NIGHT_YES:
             getDelegate().setDefaultNightMode(
                AppCompatDelegate.MODE_NIGHT_NO);
            break;
        case Configuration.UI_MODE_NIGHT_UNDEFINED:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_AUTO);
            break;
    }
    // 调用 recreate() 使设置生效
    recreate();
}
</code></pre><p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f6y5w7d0npg20dc0m841f.gif" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，这仅仅是一个简单的例子，如果涉及图片你需要创建drawable-night文件夹。</p>
<p>对于一些按钮的颜色背景都需要做相应的处理，当然处理起来还是很简单的。</p>
<p>那么现在为你的程序加上夜间模式吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://flyou.ren/2016/08/11/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="我的Blog发展史"><a href="#我的Blog发展史" class="headerlink" title="我的Blog发展史"></a>我的Blog发展史</h2><p>从12年开始写博客到现在，自己也接触了很多的博客，比如博客园，CSDD等，再到后来自己又接触到了WordPress，在上面写了一段时间总体来说是不错的，但是相应速度总是觉得有点慢。<br>于是便有了现在的博客，相比于以前用过的Blog，给予node.js 使其的响应速度可以说是相当的快，再加上MarkDown语法的支持，使得用它写作简直爽到飞，好吧就从今天开始入手吧。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>处于便于查看的目的，下面的提示命令就不删除了，哈哈。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
