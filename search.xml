<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[关于截图你所要了解的]]></title>
      <url>http://flyou.ren/2016/09/12/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%9B%BE%E4%BD%A0%E6%89%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着为什么要使用截图功能？</p>
<ul>
<li>更方便记录</li>
<li>更加便于分享</li>
<li>更加利于传输</li>
</ul>
<p>在android上有哪些截屏的方法呢？</p>
<ol>
<li>使用adb工具进行截图</li>
<li>使用android系统自带的截图</li>
<li>在自己的应用中实现截图操作</li>
</ol>
<p>今天，就对以上三种截图的方式进行下分析，写的不好的地方还请大家指正，共同进步。</p>
<p>##截图的实现</p>
<h3 id="1-使用adb命令截图"><a href="#1-使用adb命令截图" class="headerlink" title="1.使用adb命令截图"></a>1.使用adb命令截图</h3><p>系统是Android 2.3以上：</p>
<p><code>adb shell screencap -p xxx.png</code></p>
<p>系统是Android 4.0以上：</p>
<p><code>adb shell screenshot xxx.png</code></p>
<p>那么上面两个有什么区别呢？</p>
<p>screencap是从Android 2.3开始提供的一个系统级的截图工具，通过源码可以了解到screencap的实现方式，默认会从底层UI Surface去获取屏幕截图，如果失败则从linux kernel层的display framebuffer(/dev/graphics/fb0)去获取屏幕截图。</p>
<p>screenshot是从Android 4.0开始提供的另一个截图的工具， 通过源码可以发现screenshot则是直接读取/dev/graphics/fb0去获取屏幕的图像数据。</p>
<p>明白了这个，你就会清楚哪些电脑上的豌豆荚、腾讯手机管家等软件的屏幕截图功能是如何实现的了，其实就是调用这个这个api然后读取本地的图片而已。</p>
<pre><code>adb shell screencap -p /sdcard/flyou.png
adb pull /mnt/sdcard/output.png D:flyou.png
adb shell rm /sdcard/flyou.png
</code></pre><p>首先是调用系统截图命令将图片保存到sd卡下，然后调用adb pull将sd卡上的截图给拉出，最后删除本地文件。</p>
<p>需要注意的是，上面的命令在电脑上操作adb命令进行截图，手机是不需要root权限的，但是如果在手机上在手机上是需要的。</p>
<pre><code>public void shortScreen(String filepath){
Process process = null;
try{
process = Runtime.getRuntime().exec(&quot;su&quot;);
PrintStream outputStream = null;
try {
    outputStream = new PrintStream(new BufferedOutputStream(process.getOutputStream(), 8192));
    outputStream.println(&quot;screencap -p &quot; + filePath);
    outputStream.flush();
}catch(Exception e){
    Log.e(TAG, e);
} finally {
    if (outputStream != null) {
        outputStream.close();
    }
}
process.waitFor();
}catch(Exception e){
Log.e(TAG, e);
}finally {
if(process != null){
    process.destroy();
}
}
}
</code></pre><p>在手机端需要执行如上代码便可执行adb命令截图。<br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7qvwenwrkj20o50c2n04.jpg" alt=""></p>
<h3 id="2-使用android系统自带的截图"><a href="#2-使用android系统自带的截图" class="headerlink" title="2.使用android系统自带的截图"></a>2.使用android系统自带的截图</h3><p>在android系统中，大多数的截屏快捷键都是“音量-” 加上电源键实现的，当然也有一些特殊的机型是不一样的。</p>
<p>虽然，我们不能在开发中这个使用这个api，但是我们可以通过源码来看看它是如何是实现的。</p>
<p>Android源码中对按键的捕获位于文件PhoneWindowManager.java（alps\frameworks\base\policy\src\com\android\internal\policy\impl）中，这个类处理所有的键盘输入事件，其中函数interceptKeyBeforeQueueing（）会对常用的按键做特殊处理。以nexus5 和小米5为例，是同时按电源键和音量下键来截屏，那么在这个函数中我们会看到这么两段代码：</p>
<pre><code>.......
 case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE: {
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (isScreenOn &amp;&amp; !mVolumeDownKeyTriggered
                            &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                        mVolumeDownKeyTriggered = true;
                        mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
......

        case KeyEvent.KEYCODE_POWER: {
            result &amp;= ~ACTION_PASS_TO_USER;
            if (down) {
                if (isScreenOn &amp;&amp; !mPowerKeyTriggered
                        &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                    mPowerKeyTriggered = true;
                    mPowerKeyTime = event.getDownTime();
                    interceptScreenshotChord();
                }
......

//以下代码是对按键处理的判断
 private void interceptScreenshotChord() {
    if (mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; !mVolumeUpKeyTriggered) {
        final long now = SystemClock.uptimeMillis();
        if (now &lt;= mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS
                &amp;&amp; now &lt;= mPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) {
            mVolumeDownKeyConsumedByScreenshotChord = true;
            cancelPendingPowerKeyAction();

            mHandler.postDelayed(mScreenshotChordLongPress,
                        ViewConfiguration.getGlobalActionKeyTimeout());
        }
    }
}
</code></pre><p>系统截图的实现：</p>
<pre><code>private final Runnable mScreenshotChordLongPress = new Runnable() {
    public void run() {
        takeScreenshot();
    }
};

//如下为takeScreenshot()的代码
private void takeScreenshot() {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;,
                &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw())
                        msg.arg1 = 1;
                    if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw())
                        msg.arg2 = 1;
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    }
                }
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {}
        };
        if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
</code></pre><p>可以看到这个函数使用AIDL绑定了service服务到”com.android.systemui.screenshot.TakeScreenshotService”，并处理子线程返回的截图结果。</p>
<p>PS：android系统内部真的有好多实现都是靠的handler和message</p>
<pre><code>public class TakeScreenshotService extends Service {
private static final String TAG = &quot;TakeScreenshotService&quot;;

private static GlobalScreenshot mScreenshot;

private Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                final Messenger callback = msg.replyTo;
                if (mScreenshot == null) {
                    mScreenshot = new GlobalScreenshot(TakeScreenshotService.this);
                }
                mScreenshot.takeScreenshot(new Runnable() {
                    @Override public void run() {
                        Message reply = Message.obtain(null, 1);
                        try {
                            callback.send(reply);
                        } catch (RemoteException e) {
                        }
                    }
                }, msg.arg1 &gt; 0, msg.arg2 &gt; 0);
        }
    }
};

@Override
public IBinder onBind(Intent intent) {
    return new Messenger(mHandler).getBinder();
}
}
</code></pre><p>最终调用，takeScreenshot获取屏幕截图</p>
<pre><code>/**
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) {
    // We need to orient the screenshot correctly (and the Surface api seems to take screenshots
    // only in the natural orientation of the device :!)
    mDisplay.getRealMetrics(mDisplayMetrics);
    float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};
    float degrees = getDegreesForRotation(mDisplay.getRotation());
    boolean requiresRotation = (degrees &gt; 0);
    if (requiresRotation) {
        // Get the dimensions of the device in its native orientation
        mDisplayMatrix.reset();
        mDisplayMatrix.preRotate(-degrees);
        mDisplayMatrix.mapPoints(dims);
        dims[0] = Math.abs(dims[0]);
        dims[1] = Math.abs(dims[1]);
    }

    // Take the screenshot
    mScreenBitmap = Surface.screenshot((int) dims[0], (int) dims[1]);
    if (mScreenBitmap == null) {
        notifyScreenshotError(mContext, mNotificationManager);
        finisher.run();
        return;
    }

    if (requiresRotation) {
        // Rotate the screenshot to the current orientation
        Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(ss);
        c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
        c.rotate(degrees);
        c.translate(-dims[0] / 2, -dims[1] / 2);
        c.drawBitmap(mScreenBitmap, 0, 0, null);
        c.setBitmap(null);
        mScreenBitmap = ss;
    }

    // Optimizations
    mScreenBitmap.setHasAlpha(false);
    mScreenBitmap.prepareToDraw();

    // Start the post-screenshot animation
    startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,
            statusBarVisible, navBarVisible);
}
</code></pre><p>最终得到Surface.screenshot（）方法，该方法属于native 层的方法，我们已经无法对代码进行查看，但是通过该方法</p>
<pre><code>public static native Bitmap screenshot(int width, int height);
</code></pre><p>我们可以看出，底层实际上是接受了一个图片的宽高，最终给我们返回一个半成品的bitmap，然后在java层我们再对图片进行一系列的操作。</p>
<h3 id="3-在自己的应用中实现截图操作"><a href="#3-在自己的应用中实现截图操作" class="headerlink" title="3.在自己的应用中实现截图操作"></a>3.在自己的应用中实现截图操作</h3><p>上面说了好多应用之外截图方式的实现，那么如果我们想要在我们的app中实现截图功能，我们该如何实现呢？</p>
<pre><code>public class ScreenShot {   

// 获取指定Activity的截屏，保存到png文件   
private static Bitmap takeScreenShot(Activity activity，String fileName){   


//View是你需要截图的View   
View view = activity.getWindow().getDecorView();   
view.setDrawingCacheEnabled(true);   
view.buildDrawingCache();   
Bitmap b1 = view.getDrawingCache();  
view.destroyDrawingCache();   
savePic(b1,fileName)
}   


//保存到sdcard   
private static void savePic(Bitmap b,String strFileName){   
FileOutputStream fos = null;   
try {   
fos = new FileOutputStream(strFileName);   
if (null != fos)   
{   
b.compress(Bitmap.CompressFormat.PNG, 90, fos);   
fos.flush();   
fos.close();   
}   
} catch (FileNotFoundException e) {   
e.printStackTrace();   
} catch (IOException e) {   
e.printStackTrace();   
}   
}   
}  
</code></pre><p><strong>截图效果如下：</strong><br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxsmer3gj20u01hcjvv.jpg" alt=""></p>
<p>如果不想要状态栏只需要对获得bitmap进行操作，截去状态栏的高度即可</p>
<p><strong>相关代码如下：</strong></p>
<pre><code>//获取状态栏高度   
Rect frame = new Rect();   
activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);   
int statusBarHeight = frame.top;   
System.out.println(statusBarHeight);   

//获取屏幕长和高   
int width = activity.getWindowManager().getDefaultDisplay().getWidth();   
int height = activity.getWindowManager().getDefaultDisplay().getHeight();   


//去掉标题栏    
Bitmap newBitmap = Bitmap.createBitmap(b1, 0, statusBarHeight, width, height - statusBarHeight); 
</code></pre><p>这样就可以获取对应没有状态栏的图片。<br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxz0kw8uj20u01f9430.jpg" alt=""><br>但是，这样往往不能满足我们在开发中的需求，往往在开发中产品会要求我们只截去内容部分的图片，那么这时我们该怎么做呢？</p>
<p>其实方法也是很多，比如对<strong>先截去屏幕，然后对制定区域进行裁剪</strong>，<strong>使用自定义控件</strong>，其实原理也很简单，先绘制背景在确定子View的位置，再回执子View即可。但是呢这里也有几个比较简单的方法，<strong>直接获取相应布局的父布局，然后调用相关方法进行截取并保存即可</strong>。</p>
<p>下面只给出第三种方式的实现方法，如果对上面两种实现方法感兴趣的话自己可以了解下。</p>
<pre><code>View view = findViewById(R.id.share_layout);
Bitmap bmp = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
view.draw(new Canvas(bmp));
</code></pre><p>此时取到的BitMap就是你的目标布局的图片，但是使用此方法必须在数据加载完毕后使用，不然获取的截图可能是空白的，还有bitmap使用完需要记得<strong>recycle</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rog43thzj20p011iad9.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实现屏幕截图的方法有很多，实现的方法也是多种多样的，希望大家根据自己的需要都能够找到适合自己的方法，如果写的有什么纰漏的地方，欢迎大家指正讨论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定下几个小目标]]></title>
      <url>http://flyou.ren/2016/09/05/%E5%AE%9A%E4%B8%8B%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7iqwwww7yj20h809kdgu.jpg" alt=""></p>
<p>转眼已经毕业整整三个月了，一直没有好好静下来写些东西了，最近看见朋友圈都在定目标，再加上今天有空所以就也写点东西吧。</p>
<h3 id="1-瘦下来"><a href="#1-瘦下来" class="headerlink" title="1.瘦下来"></a>1.瘦下来</h3><p>自己真的是越来越胖了，自己都受不了自己了，已经从以前的120飙升到了160，哦买噶，再不瘦我真的就要变成胖子了，我不要，我不要！！</p>
<p>从今天起，每天坚持锻炼，晚上少吃点可好？当然120不是我的目标体重，要不然又要被老妈催着增肥了！！那么就140吧？</p>
<h3 id="2-沉下去"><a href="#2-沉下去" class="headerlink" title="2.沉下去"></a>2.沉下去</h3><p>毕业是毕业了，但是我认为我们都不能因为自己角色的改变而去中断学习，学习应该是贯穿每个人一生的事情。我还是希望自己能够把自己定位为一个学生，对啊学生真好。</p>
<ul>
<li>在最近的一段时间尽量把java基础和数据库操作回顾一遍</li>
<li>学习前端以及node.js相关知识，如果可以的话尽量多看看PHP吧</li>
<li>掌握几门其他语言，python和lua等</li>
<li>至于android，我还是希望自己能多学习，多记录</li>
</ul>
<h3 id="3-来写作"><a href="#3-来写作" class="headerlink" title="3.来写作"></a>3.来写作</h3><p>写作可以让我们更加巩固自己的知识，是自己的知识体系更加的清晰并完善，只有不断的写作和记录自己才会知道自己还有那些不了解，自己还有那些需要去学习。</p>
<p>当然，我觉得我平时也不会仅仅去写些关于技术的相关的，我更会在自己的博客中分享自己的心得以及对某一件事的看法，因为写作也是使人放松的一种方法，那么我们为什么不坚持呢？</p>
<h3 id="4-去旅游"><a href="#4-去旅游" class="headerlink" title="4.去旅游"></a>4.去旅游</h3><p>2016年已经过去了一大半，说好的出玩计划因为各种原因都没有实现，最近心里也是有许多的额事情，感觉心得压力很大，真的觉得自己必须要出去转转了，至于目的地是哪，我觉得都是可以的，厦门？杭州？南京？或者是西藏吧。</p>
<p>一个人或者约三两个好友感觉去哪里都是不错的，是的，是时候出去转转了呢！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，我的小目标定好了，希望自己的目标能够在新年前实现吧，这样我才好写我的年终总结啊。</p>
<p>于：2016/9/5 15:59:15 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android夜间模式浅析]]></title>
      <url>http://flyou.ren/2016/08/18/android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="几种实现夜间模式的方式"><a href="#几种实现夜间模式的方式" class="headerlink" title="几种实现夜间模式的方式"></a>几种实现夜间模式的方式</h2><h3 id="1：修改theme，重启activity"><a href="#1：修改theme，重启activity" class="headerlink" title="1：修改theme，重启activity"></a>1：修改theme，重启activity</h3><p>使用时定义不同的主题，通过切换主题重启acticity的方式完成切换</p>
<p><strong>优点</strong>：正儿八经的夜间模式，配色看着舒服</p>
<p><strong>缺点</strong>：图片刺眼、闪屏</p>
<h3 id="2：覆盖一定透明度的View"><a href="#2：覆盖一定透明度的View" class="headerlink" title="2：覆盖一定透明度的View"></a>2：覆盖一定透明度的View</h3><p>使用一个带黑色带透明度的View，盖在现有的activity上，效果类似你带上墨镜，看着太阳不刺眼。</p>
<p><strong>优点</strong>：不用重启activity，不闪屏；加上透明度过渡动画，模式之间切换非常舒服，解决了1中，白底图片依旧刺眼的问题。</p>
<p><strong>缺点</strong>：配色没变化，就算带上墨镜，白天依旧是白天。</p>
<h3 id="3：使用动态换肤方案"><a href="#3：使用动态换肤方案" class="headerlink" title="3：使用动态换肤方案"></a>3：使用动态换肤方案</h3><p>一般借助于第三方库完成换肤，如：<br><a href="https://github.com/hongyangAndroid/ChangeSkin" target="_blank" rel="external">https://github.com/hongyangAndroid/ChangeSkin</a><br><a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">https://github.com/fengjundev/Android-Skin-Loader</a></p>
<p><strong>优点</strong>：不用重启activity，不闪屏；可以为程序提供多种皮肤方案不局限于夜间/白天模式。</p>
<p><strong>缺点</strong>：在制作方面代价过大，侵入性较强，需要以来第三方库完成，可靠性不能得到保证。</p>
<h3 id="4：使用-Support-Library-23-2-0-DayNight主题实现"><a href="#4：使用-Support-Library-23-2-0-DayNight主题实现" class="headerlink" title="4：使用 Support Library 23.2.0 DayNight主题实现"></a>4：使用 Support Library 23.2.0 DayNight主题实现</h3><p><strong>优点</strong>：Google自家产品，可靠性高，配置简单，省心省力，在仅仅需要实现夜间/日间模式的应用内强烈推荐。</p>
<p><strong>缺点</strong>：不支持多皮肤切换算吗？貌似今天只谈夜间模式的实现……。</p>
<h2 id="使用DayNight主题来实现夜间模式"><a href="#使用DayNight主题来实现夜间模式" class="headerlink" title="使用DayNight主题来实现夜间模式"></a>使用DayNight主题来实现夜间模式</h2><p>对于前两种方式来说，从实现来说是不困难的但是对用户的体验在一定程度上是很不好的，一个需要重启activity，一个配色无法改变都是我们不推荐的。</p>
<p>当然第三种方式市面上也有比较成熟的第三方库来完成程序的换肤，但是对于单单需要夜间模式的应用来说未免有些大材小用了。</p>
<p>今天我们使用DayNight主题来实现换肤功能。</p>
<h3 id="1-定义DayNight主题，及相关属性"><a href="#1-定义DayNight主题，及相关属性" class="headerlink" title="1.定义DayNight主题，及相关属性"></a>1.定义DayNight主题，及相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;</div><div class="line">      &lt;!-- Customize your theme here. --&gt;</div><div class="line">      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</div><div class="line"> 		&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>可以在主题中定义一些颜色尺寸等属性，在vlaues的colors.xml 声明color属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>在res下面创建values-night文件夹，创建colors.xml声明color属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#1f2023&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#18181a&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<h3 id="2-为程序设置初始模式"><a href="#2-为程序设置初始模式" class="headerlink" title="2.为程序设置初始模式"></a>2.为程序设置初始模式</h3><p>程序中进行主题的初始化。你需要调用 AppCompatDelegate.setDefaultNightMode() ，它有四个参数：</p>
<p>MODE_NIGHT_NO. 使用亮色（light）主题</p>
<p>MODE_NIGHT_YES. 使用暗色（dark）主题</p>
<p>MODE_NIGHT_AUTO. 根据当前时间自动切换 亮色（light）/暗色（dark）主题</p>
<p>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统，通常为 MODE_NIGHT_NO</p>
<p>如在Application中进行初始化：</p>
<pre><code>public class MyApplication extends Application {
static {
    AppCompatDelegate.setDefaultNightMode(
            AppCompatDelegate.MODE_NIGHT_NO);
}

@Override
public void onCreate() {
    super.onCreate();
}

}
</code></pre><h3 id="3-在初始化时就切换夜间模式"><a href="#3-在初始化时就切换夜间模式" class="headerlink" title="3.在初始化时就切换夜间模式"></a>3.在初始化时就切换夜间模式</h3><pre><code> public class MyActivity extends AppCompatActivity {
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
        // Set the local night mode to some value
        getDelegate().setLocalNightMode(
                AppCompatDelegate.MODE_NIGHT_...);
        // 调用 recreate() 使设置生效
        recreate();
    }
} }
</code></pre><h3 id="4-如何获取当前主题的状态"><a href="#4-如何获取当前主题的状态" class="headerlink" title="4.如何获取当前主题的状态"></a>4.如何获取当前主题的状态</h3><pre><code>int currentNightMode = getResources().getConfiguration().uiMode
    &amp; Configuration.UI_MODE_NIGHT_MASK;

case Configuration.UI_MODE_NIGHT_NO:

case Configuration.UI_MODE_NIGHT_YES:

case Configuration.UI_MODE_NIGHT_UNDEFINED:
</code></pre><p>可以通过上面面的几种状态来进行相应的操作如：<br>```<br> private void judeStatusOfDayNight() {</p>
<pre><code>    int currentNightMode = getResources().getConfiguration().uiMode
            &amp; Configuration.UI_MODE_NIGHT_MASK;
    switch (currentNightMode) {
        case Configuration.UI_MODE_NIGHT_NO:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_YES);


            break;
        case Configuration.UI_MODE_NIGHT_YES:
             getDelegate().setDefaultNightMode(
                AppCompatDelegate.MODE_NIGHT_NO);
            break;
        case Configuration.UI_MODE_NIGHT_UNDEFINED:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_AUTO);
            break;
    }
    // 调用 recreate() 使设置生效
    recreate();
}
</code></pre><p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f6y5w7d0npg20dc0m841f.gif" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，这仅仅是一个简单的例子，如果涉及图片你需要创建drawable-night文件夹。</p>
<p>对于一些按钮的颜色背景都需要做相应的处理，当然处理起来还是很简单的。</p>
<p>那么现在为你的程序加上夜间模式吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://flyou.ren/2016/08/11/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="我的Blog发展史"><a href="#我的Blog发展史" class="headerlink" title="我的Blog发展史"></a>我的Blog发展史</h2><p>从12年开始写博客到现在，自己也接触了很多的博客，比如博客园，CSDD等，再到后来自己又接触到了WordPress，在上面写了一段时间总体来说是不错的，但是相应速度总是觉得有点慢。<br>于是便有了现在的博客，相比于以前用过的Blog，给予node.js 使其的响应速度可以说是相当的快，再加上MarkDown语法的支持，使得用它写作简直爽到飞，好吧就从今天开始入手吧。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>处于便于查看的目的，下面的提示命令就不删除了，哈哈。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
