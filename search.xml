<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Dagger2入门]]></title>
      <url>http://flyou.ren/2017/01/13/Dagger2%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>众所周知Dagger是一个依赖注入(Dependency Injection)框架简称DI，那么什么是依赖注入呢？其实熟悉Spring的小伙伴应该都非常清楚，因为Spring的核心思想就是依赖注入，管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。</p>
<p>那么到底什么是依赖注入呢？</p>
<blockquote>
<p>对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。也就是说，被注入的对象不需要重复的初始化就可以获得相应的引用。</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcituqblytj20go0go0ss.jpg" alt=""></p>
<p>比如说小明去超市买酱油，这样我们肯定需要一个小明的对象和酱油的对象。</p>
<p>物品基类</p>
<pre><code>public class Things{

}  
</code></pre><p>酱油类</p>
<pre><code>public class Sauce extend Things{

public void sauce(String type,float price){

    }
}
</code></pre><p>小明类</p>
<pre><code>public class XiaoMing {
Things sauce=new Sauce(&quot;海天&quot;，5.6$);

/**
 * 买的动作
 * @param object
 */
private  void buy(Things things){
……
……
}
……
…………
………………
}
</code></pre><p>代码看起来貌似没有什么大问题，但是可以注意酱油在小明类中高度耦合，也就是说明天小明不打酱油了，去买毛线的时候小明这个类就要发生更改，后天买棒棒糖的时候当然也需要更改，这样下来小明没累死，我累死了。</p>
<p>如果使用依赖注入就不一样了</p>
<p>小明类</p>
<pre><code>public class XiaoMing {
@Inject
Things things;

/**
 * 买的动作
 * @param object
 */
private  void buy(Things things){
……
……
}
……
…………
………………
}
</code></pre><p>我们根本不需要关注小明究竟买什么，也不用关注买的东西的颜色、大小、价格。也就是说被注入的地方会自动获得一个初始化好的对象。</p>
<h2 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h2><h3 id="Dagger2简介"><a href="#Dagger2简介" class="headerlink" title="Dagger2简介"></a>Dagger2简介</h3><p>Dagger2是Dagger1的分支，由谷歌公司接手开发，目前的版本是2.0。Dagger2是受到AutoValue项目的启发。Dagger是依赖注入的一种，说到依赖注入，标准定义是目标类中所依赖的其他的类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以把其他的类的已经初始化好的实例自动注入到目标类中。说简单就是一次构建，到处注入。</p>
<h3 id="使用Dagger2的好处"><a href="#使用Dagger2的好处" class="headerlink" title="使用Dagger2的好处"></a>使用Dagger2的好处</h3><ol>
<li><p>依赖的注入和配置独立于组件之外。</p>
</li>
<li><p>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</p>
</li>
<li><p>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</p>
</li>
</ol>
<h3 id="Dagger2基本组成"><a href="#Dagger2基本组成" class="headerlink" title="Dagger2基本组成"></a>Dagger2基本组成</h3><ul>
<li>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</li>
<li>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的 依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</li>
<li>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</li>
<li>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。</li>
</ul>
<h3 id="Dagger2简单入门"><a href="#Dagger2简单入门" class="headerlink" title="Dagger2简单入门"></a>Dagger2简单入门</h3><ul>
<li>引入Dagger</li>
</ul>
<p>首先在项目根目录的 build.gradle文件中引入apt</p>
<pre><code>buildscript {
repositories {
    jcenter()
}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.2.3&apos;
    //引入相应apt
    classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
    }
}

allprojects {
repositories {
    jcenter()
}
}
</code></pre><p>然后在所在module的build.gradle做如下配置</p>
<pre><code>//首先引入 apt
apply plugin: &apos;com.neenbedankt.android-apt&apos;
……
……
dependencies {
//java注解
provided &apos;javax.annotation:javax.annotation-api:1.2&apos;
//dagger2
compile &apos;com.google.dagger:dagger:2.5&apos;
//dagger编译器
apt &apos;com.google.dagger:dagger-compiler:2.5&apos;
}
</code></pre><ul>
<li>简单例子</li>
</ul>
<p>下面继续举个简单的栗子。<br>把User对象的值赋值到Activity里去。<br>代码的简单结构如下</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj93ewswoj208q04rt8w.jpg" alt=""></p>
<p>User类</p>
<pre><code>public class User {
private String name;
private int age;

public User() {
}

public User(String name, int age) {
    this.name = name;
    this.age = age;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}
}
</code></pre><p>UserModule类</p>
<pre><code>@Module//标识该类提供依赖
public class UserModule {
@Provides//告诉Dagger我们想要构造对象并提供这些依赖
User provideUser() {
    return new User(&quot;周杰伦&quot;, 38);
}
}
</code></pre><p>UserComponent类</p>
<pre><code>//Component 链接被注入的地方和提供依赖的地方
@Component(modules = UserModule.class)
public interface UserComponent {
void inject(DaggerActivity activity);
}
</code></pre><p><strong>这个时候简单的注入就基本完成了，但是我们注意到Component文件是一个接口文件，我们肯定无法直接使用，现在我们需要借助于Dagger让它帮助我们根据注解生成对象</strong></p>
<p>点击android studio的工具栏的 make progect</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj9j67r96j20ff01h74j.jpg" alt=""></p>
<p>或者</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj9jxg4n8j207i08q0tr.jpg" alt=""></p>
<p>就会在bulid文件夹下生成相应的文件如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcj9l6t8bpj20c00abt9j.jpg" alt=""></p>
<p>当然我们用到的暂时只有以Dagger开头的Component文件，这个时候我们就可以在activity中使用完成User的注入了</p>
<p>DaggerActivity类</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
//需要注入User对象
@Inject
User user;
UserComponent userComponent;
private TextView textView;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    //完成对User的注入
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    //根据注入的User对象设置TextView
    textView.setText(user.getName()+&quot;:&quot;+user.getAge());
}
}
</code></pre><p>布局文件就不在放出来了，就是一个简单的textview。具体效果如下。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcj9unkwyhj20u00fegme.jpg" alt=""></p>
<p>这样我们就完成了Dagger的一个简单的注入，下面会介绍Dagger的一些进一步的用法</p>
<h3 id="Dagger2深入学习"><a href="#Dagger2深入学习" class="headerlink" title="Dagger2深入学习"></a>Dagger2深入学习</h3><h4 id="Singleton-使用该注解实现单例的效果"><a href="#Singleton-使用该注解实现单例的效果" class="headerlink" title="@Singleton 使用该注解实现单例的效果"></a>@Singleton 使用该注解实现单例的效果</h4><p>还是上面的栗子，如果我们在Activity中注入两个User对象</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
@Inject
User user1;
@Inject
User user2;

UserComponent userComponent;
private TextView textView;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    textView.setText(&quot;user1--&gt;&quot;+user1.toString()+&quot;\nuser2--&gt;&quot;+user2);

}
}
</code></pre><p>然后对比两者的地址。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcjam2ptdkj20u00gzac7.jpg" alt=""></p>
<p>可以发现两者的地址并不相同，可见Dagger为我们生成了两个对象，但是我们有时候并不需要两个对象，如一些全局的配置<br>SharedPreferences 对象、数据库管理对象等，要是在平时我们就必须自己通过手写单例来实现，但是使用Dagger的@Singleton 注解我们就可以很轻松的完成对象的单例，而丝毫不用考虑单例如何实现。</p>
<p>UserModule类</p>
<pre><code>@Module
public class UserModule {
@Singleton
@Provides
User provideUser() {
    return new User(&quot;周杰伦&quot;, 38);
    }
}
</code></pre><p>UserComponent类</p>
<pre><code>@Singleton
@Component(modules = UserModule.class)
public interface UserComponent {
void inject(DaggerActivity activity);
}
</code></pre><p>只需要一个简单的注解就可以实现单例。这时候我们需要重新点击 make project来重新生成编译注解。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcjassogqpj20u00htgnr.jpg" alt=""></p>
<p>再次运行，我们可以看到这次Dagger只为我们生成了一个对象。</p>
<h4 id="Scope-Scopes自定义注解作用域"><a href="#Scope-Scopes自定义注解作用域" class="headerlink" title="@Scope: Scopes自定义注解作用域"></a>@Scope: Scopes自定义注解作用域</h4><p>Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。如PerApp、perActivity等</p>
<p>PerActivity</p>
<pre><code>@Scope
@Retention(RUNTIME)
public @interface PerActivity {}
</code></pre><p>PerApp</p>
<pre><code>@Scope
@Retention(RUNTIME)
public @interface PerApp {}
</code></pre><p>该自定义注解需要同时在Module和component中使用才会起作用，会在下面的栗子中进一步说明。</p>
<h4 id="其他相关注解"><a href="#其他相关注解" class="headerlink" title="其他相关注解"></a>其他相关注解</h4><p>@Qualifier限定符，可以对注解做出一定的限定，具体可以参照java相关注解。</p>
<p>懒加载 lazy 即在等到调用的时候才注入。<br>在使用的地方使用user.get()就能得到一个User对象</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
@Inject
Lazy &lt;User&gt; user;

UserComponent userComponent;
private android.widget.TextView textView;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    User myUser = this.user.get();
    textView.setText(myUser.getName()+&quot;:&quot;+ myUser.getAge());
}

}
</code></pre><h3 id="Dagger与MVP结合"><a href="#Dagger与MVP结合" class="headerlink" title="Dagger与MVP结合"></a>Dagger与MVP结合</h3><p>上面讲了那么多的Dagger的基础，我们还没有进行真正的运用，接下来我们就结合MVP（如果不知道什么是MVP的话，自行Gogle）来一起来做一个简单的栗子。</p>
<p>首选看一下简单的代码结构</p>
<p><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1fcjbgzex2nj209l0addgm.jpg" alt=""></p>
<p>可以看到我们仅仅是在原来的MVP结构上新增两个（module和component），与MVP的结合我们主要是用在对persenter的改造上，完成对Persenter的注入。</p>
<p>由上述的代码命名我们可以很容易的看出这是一个简单模拟登陆的栗子，在model层主要完成登陆判断的逻辑，在persenter层主要是对View的控制，在module主要是完成persenter注入提供依赖，在component层主要是协调被注入Activity和module的关系。</p>
<p>User.class</p>
<pre><code>public class User {
private String userName;
private String password;

public User() {
}

public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
}

public String getUserName() {
    return userName;
}

public void setUserName(String userName) {
    this.userName = userName;
}

public String getPassword() {
    return password;
}

public void setPassword(String password) {
    this.password = password;
}
}
</code></pre><p>ILoginModel.class</p>
<pre><code>public interface ILoginModel {

void login(String userName, String password,LoginListener listener);

interface LoginListener {
    void loginSuccess();
    void loginFailed(String msg);
}
}
</code></pre><p>LoginModelImpl.class</p>
<p>完成登陆逻辑，这里可以进行网络操作，完成登陆操作，这次我们仅仅在本地模拟判断用户名和密码，这里使用postDelayed（）来模拟网络操作。</p>
<pre><code>public class LoginModelImpl implements ILoginModel {

@Override
public void login(String userName, String password, LoginListener listener) {
     new Handler().postDelayed(new Runnable() {
        @Override
        public void run() {
    if (userName.equals(&quot;flyou&quot;) &amp;&amp; password.equals(&quot;553274238&quot;)) {
        listener.loginSuccess();
    } else {
        listener.loginFailed(&quot;用户名密码错误&quot;);
    }
      },2000);
}
}
</code></pre><p>ILoginView.class</p>
<p>提供视图相关接口</p>
<pre><code>public interface ILoginView {
void showLoading();
void hideLoading();
void showError(String msg);
void LoginSuccess();
}
</code></pre><p>LoginPersenter.class</p>
<p>完成View和数据的协调。</p>
<pre><code>public class LoginPersenter {
private ILoginView loginView;
private ILoginModel loginModel;

public LoginPersenter(ILoginView loginView) {
    this.loginModel=new LoginModelImpl();
    this.loginView = loginView;
}
public void login(final String userName, final String password){
    loginView.showLoading();

            loginModel.login(userName, password, new ILoginModel.LoginListener() {
                @Override
                public void loginSuccess() {
                    loginView.hideLoading();
                    loginView.LoginSuccess();
                }

                @Override
                public void loginFailed(String msg) {
                    loginView.hideLoading();
                    loginView.showError(msg);
                }
            });
        }
       }
}
</code></pre><p>PerApp.class</p>
<p>自定义注解范围</p>
<pre><code>@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)

public @interface PerApp {
}
</code></pre><p>LoginPersenterModule.class</p>
<p><strong>和上面简单的例子一样我们需要使用LoginPersenter就要完成对LoginPersenter的注入，唯一不同就是这里的我们是这里我们依赖的LoginPersenter需要参数，那么我们再这里就要完成第参数的依赖，如果有多个参数我们就要完成对多个参数的依赖</strong></p>
<pre><code>@Module
public class LoginPersenterModule {
private LoginActivity loginActivity;

public LoginPersenterModule(LoginActivity loginActivity) {
    this.loginActivity = loginActivity;
}
@PerApp
@Provides
LoginActivity provideLoginActivity(){
    return loginActivity;
}

@PerApp
@Provides
LoginPersenter ProvideLoginPersenter(LoginActivity loginActivity){
    return new LoginPersenter(loginActivity);
}
}
</code></pre><p>LoginPersenterCompoent.class<br>完成module与注入地方的关系协调</p>
<pre><code>@PerApp//定义注解范围
@Singleton
@Component(modules = LoginPersenterModule.class)
public interface LoginPersenterCompoent {
void inject(LoginActivity activity);
}
</code></pre><p>LoginActivity.class</p>
<pre><code>public class LoginActivity extends AppCompatActivity implements ILoginView {
@Inject
LoginPersenter loginPersenter;
private LoginPersenterCompoent loginPersenterCompoent;
private android.widget.EditText userName;
ProgressDialog progressDialog;
PasswordToggleEditText2 password;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_login);
    this.password = (PasswordToggleEditText2) findViewById(R.id.password);
    this.userName = (EditText) findViewById(R.id.userName);
    loginPersenterCompoent= DaggerLoginPersenterCompoent.builder()
    .loginPersenterModule(new LoginPersenterModule(this)).build();
    loginPersenterCompoent.inject(this);
}

public void login(View view) {
    loginPersenter.login(userName.getText().toString().trim(),password.getText().toString().trim());

}

@Override
public void showLoading() {
     progressDialog=ProgressDialog.show(LoginActivity.this,&quot;正在登录&quot;,&quot;正在登录请稍后……&quot;,true,false);
}

@Override
public void hideLoading() {
    progressDialog.dismiss();
}

@Override
public void showError(String msg) {
    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
}

@Override
public void LoginSuccess() {
    Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();
}
}
</code></pre><p>布局文件真的很简单，就不再贴出了。</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1fcjx0fejoyg20dc0npqjg.gif" alt=""></p>
<p>到这里，文章就基本结束了，笔者有什么写错的地方欢迎拍砖~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[应用安全之[adb backup]]]></title>
      <url>http://flyou.ren/2016/12/16/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E4%B9%8B%5Badb%20backup%5D/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先讲个故事，小杰喜欢上了公司的女同事，但是却不敢向她要联系方式，偶然间她发现女同事竟然还上探探，于是小杰立刻拿起了手机在自己手机上下载了一个探探。滑了整整一星期都没遇见女同事，屏保都划破了……<br><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/82711797-file_1487230714653_10813.png" alt=""></p>
<p>作为同事的小明终于看不下去了，就提出了要帮他的想法，说可以帮助小杰帮忙把女同事的探探设置自己为暗恋对象，小杰不敢相信但是还是非常虔诚的接受了小明提出的帮助。</p>
<p>一天后，小杰请小明大吃了一顿……</p>
<p>事情的经过是这样的，小明以测试为由说要用女同事的手机，于是女同事就来到小明的座位上，看着小明用自己的手机进行测试，可是小明就敲了几行命令就把手机还给了女同事并连声道谢，不解的女同事寒暄着离开了。然后事情就按照小明所说的发生了……<br><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/56357804-file_1487231323629_17b7d.png" alt=""></p>
<p>##到底发生了什么</p>
<h3 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h3><blockquote>
<p>在谷歌2010年发布Android 2.2 Froyo (冻酸奶)系统中，谷歌引入一个了系统备份的功能，允许用户备份系统应用和第三方应用的apk安装包和应用数据，以便在刷机或者数据丢失后恢复应用。 第三方应用开发者需要在应用的AndroidManifest.xml文件中配置allowBackup标志(默认为true)来设置应用数据是否能能够 被备份或恢复。</p>
<p>当这个标志被设置为true时应用程序数据可以在手机未获取ROOT的情况下通过adb调试工具来备份和恢复，这就允许恶意攻击者在接触用户手机的情况下 在短时间内启动手机USB调试功能来窃取那些能够受到AllowBackup漏洞影响的应用的数据，造成用户隐私泄露甚至财产损失。</p>
</blockquote>
<h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><p>接下来就来讲一下到底发生了什么。</p>
<p>首先小明邀请女同事来到自己的座位，把女同事的手机连接到了自己的PC上,并敲下了如下命令，确保了女同事的手机已经和自己的PC进行了连接</p>
<pre><code>adb devices
</code></pre><p><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/75451917-file_1487231636025_10084.png" alt=""><br>然后敲下了如下命令：</p>
<pre><code>adb backup -nosystem -noshared -apk -f com.tantan.apk com.p1.moblie.putong
</code></pre><p>并在女同事手机上点了个确认按钮，30秒后就把手机还给了女同事。</p>
<p><strong> adb backup</strong>又是什么鬼？</p>
<p>adb backup是adb众多命令中的一个，主要作用是备份手机中的文件，其命令操作如下：</p>
<p>adb backup [-f <file>] [-apk|-noapk] [-shared|-noshared][-all] [-system|nosystem][<packages...>]<br><br>参数简介：<br>代码 -f<file>设置备份后的文件名和路径。比如”C:\dxy.ab”，扩展名是ab。<br><br>代码:-apk|-noapk选择是否备份APK程序本身。<br><br>代码:-shared|-noshared是否备份SD卡。<br><br>代码:-system|-nosystem是否备份系统程序。<br><br>代码:<packages...>指定备份具体的应用程序。<br></packages...></file></packages...></file></p>
<p>看了如上介绍想必大家就清楚了，小明使用该条命令把女同事手机上的探探应用以及该应用的用户资料一并备份到了自己的电脑上。<br><br><strong>com.tantan.apk</strong>对就是这个文件，虽然这个问价是apk结尾的但他不是一个可安装的apk文件，我们不能直接去安装这个应用。在备份的时候我们可以给这个文件起任意的名字，放在任意的位置。我里没有指定目录，所以文件就保存在命令行当时所在的位置。D:</p>
<p>接下来，小明拿来了小杰的手机然后又敲了一条命令。</p>
<pre><code>adb restore com.tantan.apk
</code></pre><p>在小杰的手机上点了次确认，这样小杰的手机上就装了一个和女同事一样的探探</p>
<p><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/31412667-file_1487232736235_d3a8.png" alt=""></p>
<p>然后他把女同事的暗恋对象设成了自己，把自己的暗恋对象设成了女同事</p>
<h2 id="唠叨"><a href="#唠叨" class="headerlink" title="唠叨"></a>唠叨</h2><p>还好这次的小杰是没有恶意的，不然就不好了……</p>
<p>试想一下，如果是的网盘或者是团购应用被别人取得的话，会发生什么。当然我没有去试太多应用是否存在这样的问题，XX网盘，XX哪，XX团购均还存在这样的问题。</p>
<p><strong>最后申明下，我写下这篇文章没有什么恶意，只是想更多的开发者提高自己的开发意识，在应用上线时尽量关闭allowBackup，还有就是建议用户提高安全意识，手机加一个锁，如果手机加密的话那么刚才的故事就不会发生了。最后，关于为什么用探探举证例子，因为小杰真的在用探探啊</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信扫一扫揭秘]]></title>
      <url>http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要探索二维码的秘密之前，我们首先需要简单了解下什么是二维码。</p>
<h3 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h3><blockquote>
<p>二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</p>
</blockquote>
<p>其实简单的说二维码就是一段简单的字符串图形化的展示，它可能是一个url，一段文字，或者是一首唐诗也不错哦<br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rxxbqqnsj207s07sgmr.jpg" alt="二维码1"><br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7rxyajt8nj207s07sjrt.jpg" alt="二维码2"><br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7rxz0bdixj207s07s75b.jpg" alt="二维码3"></p>
<h3 id="为什么要使用二维码"><a href="#为什么要使用二维码" class="headerlink" title="为什么要使用二维码"></a>为什么要使用二维码</h3><p>二维码的诞生可以说是真正的促进这移动互联网的发展。</p>
<ul>
<li>信息获取（名片、地图、WIFI密码、资料）</li>
<li>网站跳转（跳转到微博、手机网站、网站）</li>
<li>广告推送（用户扫码，直接浏览商家推送的视频、音频广告）</li>
<li>手机电商（用户扫码、手机直接购物下单）</li>
<li>防伪溯源（用户扫码、即可查看生产地；同时后台可以获取最终消费地)</li>
<li>优惠促销（用户扫码，下载电子优惠券，抽奖）</li>
<li>会员管理（用户手机上获取电子会员信息、VIP服务）</li>
<li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付）</li>
</ul>
<p>在不同的领域，不同的行业二维码都可以用来简化原来的工作流程，那么我们为什么不来试试二维码呢？</p>
<h3 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h3><p>通过对上面的了解相信大家对二维码已经有了一定的了解，那么二维码是怎么生成的呢?</p>
<blockquote>
<p>维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x<br>25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)<em>4 + 21（V是版本号） 最高Version<br>40，(40-1)</em>4+21 = 177，所以最高是177 x 177 的正方形。      </p>
</blockquote>
<p><strong>二维码的基本结构如下：</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7rz07e9bhj20le0cuaax.jpg" alt=""></p>
<p>二维码一般由定位点图案、功能性数据、数据码和纠错码组成，生成的算法是固定的有需要的同学可以了解<br><a href="https://my.oschina.net/DeanCTO/blog/205677" title="二维码的生成原理" target="_blank" rel="external">二维码的生成原理</a>、<br><a href="http://blog.csdn.net/kelindame/article/details/45155185" title="二维码生成原理解析" target="_blank" rel="external">二维码生成原理解析</a><br>如今，基本上各个语言都有了比较好的二维码生成与解码的开源项目，有需要的同学可以自行google，本次我们呢不做具体介绍，因为不是重点啊 。</p>
<h2 id="微信二维码揭秘"><a href="#微信二维码揭秘" class="headerlink" title="微信二维码揭秘"></a>微信二维码揭秘</h2><h3 id="微信的二维码有哪些"><a href="#微信的二维码有哪些" class="headerlink" title="微信的二维码有哪些"></a>微信的二维码有哪些</h3><p>在平时的使用中我们可以发现微信在很多的场景中都有二维码的使用在，名片，联系人，支付等尤为明显，可以说二维码已经成为微信不可或缺的设计呢功能了。<br>那么微信的二维码到底有哪些是呢？</p>
<p><strong>以二维码扫描结果和功能区分</strong></p>
<ol>
<li>http(s)://www.<em>*</em>.com http链接</li>
<li>weixin://qr/××× 微信二维码</li>
<li><a href="http://weixin.qq.com/r/×××" target="_blank" rel="external">http://weixin.qq.com/r/×××</a> 微信二维码名片</li>
<li><a href="https://login.weixin.qq.com/l/×××" target="_blank" rel="external">https://login.weixin.qq.com/l/×××</a> 网页登陆二维码</li>
<li><a href="https://login.wechatapp.com/l/×××" target="_blank" rel="external">https://login.wechatapp.com/l/×××</a> 国际部网页登陆二维码</li>
<li>weixin://wxpay/bizpayurl/××× 微信支付</li>
<li><a href="http://weixin.qq.com/g/×××" target="_blank" rel="external">http://weixin.qq.com/g/×××</a> 微信群二维码</li>
</ol>
<p>其实在上面的二维码例子中大体上可以分为两类，1，4，5未一类，其他的为一类。第一类主要是普通类型和涉及登录相关的逻辑，第二类中的逻辑就是我们本次要谈论的逻辑。</p>
<p><strong>第二类流程如下：</strong><br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rypqmgpjj20uk061js1.jpg" alt="流程图"></p>
<h3 id="实现微信二维码逻辑"><a href="#实现微信二维码逻辑" class="headerlink" title="实现微信二维码逻辑"></a>实现微信二维码逻辑</h3><p>由上面的介绍我们很清楚的知道，我们想要实现上面的功能我们生成的二维码肯定是一个url，然后对本本地是否安装有app的判断也是在服务端实现的（其实就是个js而已，不要怕），当然在客户端也需要对自己的代码做相应的配置。</p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>由于本人系Android开发工程师，对ios的了解也不是太多，所以本次配置主要是对android端而言的。<br>首先在manifest文件中配置扫描后需要跳转activity的intent-filter</p>
<p>还需要制定对应的host、pathPrefix、scheme<br>至于host、pathPrefix、scheme是什么，大家可以自己去google下，其实只要了解Url的组成原理就ok了。</p>
<pre><code>&lt;activity android:name=&quot;.otherTest.scan.FromUrlActicity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
            &lt;data
                android:host=&quot;www&quot;
                android:pathPrefix=&quot;/com/test&quot;
                android:scheme=&quot;flyou&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><p>上面的host和 pathPrefix是可以省略的，不过还是推荐大家都写上。<br>这样客户端的配置就完成了。        </p>
<h4 id="服务端解析"><a href="#服务端解析" class="headerlink" title="服务端解析"></a>服务端解析</h4><p>首先根据浏览器的userAgent判断来自哪个终端，如果是PC则直接跳转到下载页，如果是Android或者Ios则判断本地判断本地app书否存在如果存在则根据定义的scheme打开相应页面并传递数据，如果不存在该app则跳转到下载页面。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;我是一个测试页面&lt;/title&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=320.1, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

&lt;script&gt;
/*获取自定义数据*/
function getQueryString(name) {  
    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);  
    var r = window.location.search.substr(1).match(reg);  
    if (r != null) return unescape(r[2]);  
    return null;  
}  
var userId=getQueryString(&quot;userId&quot;);
var u = navigator.userAgent || &apos;&apos;;
 /*首先判断是否是pc，若是pc访问则跳转到http://flyou.ren/ */
var isPC = !/(iphone|ios|android|mini|mobile|mobi|Nokia|Symbian|iPod|iPad|Windows\s+Phone|MQQBrowser|wp7|wp8|UCBrowser7|UCWEB|360\s+Aphone\s+Browser)/i.test(u);
var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //android终端或者uc浏览器
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if (isPC) { location.href = &quot;http://flyou.ren/&quot;; }
else if (isAndroid) {
    var the_href=&quot;http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98&quot;;//获得下载链接或在app下载页
    location.href=&quot;flyou://www/com/test?userId=&quot;+userId;//打开某手机上的某个app应用，并传递参数
    setTimeout(function(){
        window.location=the_href;//如果超时就跳转到app下载页，或者直接下载
    },2000);
}
else{
    //服务端可以根据ios 先关逻辑做相应的判断
    alert(&apos;宝宝暂时还不持支持IOS操作系统，宝宝会努力的&apos;)
}

&lt;/script&gt;


&lt;/head&gt;

&lt;/html&gt;
</code></pre><h4 id="服务端返回数据处理"><a href="#服务端返回数据处理" class="headerlink" title="服务端返回数据处理"></a>服务端返回数据处理</h4><p>在对应的Acticity里处理传递回来的参数，并做相应的处理，如微信名片二维码的功能，返回给相应页面用户id，当然这个用户的userId可以是经过加密的（别我问我怎么加密，你们这么加密我也不想知道）。</p>
<pre><code>public class FromUrlActicity extends AppCompatActivity {

private TextView tvUserid;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_qrcode_acticity);
    tvUserid = (TextView) findViewById(R.id.userid);
    Uri uriData = this.getIntent().getData();
    String userId = uriData.getQueryParameter(&quot;userId&quot;);

    tvUserid.setText(&quot;我是来自服务器的UserId:&quot;+userId);

    }
}
</code></pre><h4 id="扫描二维码"><a href="#扫描二维码" class="headerlink" title="扫描二维码"></a>扫描二维码</h4><p>自己或者使用第三方工具生成二维码如下</p>
<p><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s0hmygplj207s07s752.jpg" alt=""></p>
<p><strong>二维码对应字符串：http:\henu.flyou.ren/scan?userId=553274238</strong></p>
<p>在手机上使用浏览器扫一扫扫描二维码即可进入如下界面，并获得服务端传来的参数，完成相应的逻辑<br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s01h4fndj20u00fwwfz.jpg" alt=""></p>
<p>当然，二维码可以向服务器传递多个数据，服务器也可以向客户端返回多个数据，分别定义获取即可。明白了上述的流程想要实现微信的上述流程也是很容易的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，二维码的功能并不仅仅局限于上面的逻辑，二维码可以应用在多个行业和领域，那么快快发动你的才智来发现新的大陆吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于截图你所要了解的一切]]></title>
      <url>http://flyou.ren/2016/09/12/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%9B%BE%E4%BD%A0%E6%89%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着为什么要使用截图功能？</p>
<ul>
<li>更方便记录</li>
<li>更加便于分享</li>
<li>更加利于传输</li>
</ul>
<p>在android上有哪些截屏的方法呢？</p>
<ol>
<li>使用adb工具进行截图</li>
<li>使用android系统自带的截图</li>
<li>在自己的应用中实现截图操作</li>
</ol>
<p>今天，就对以上三种截图的方式进行下分析，写的不好的地方还请大家指正，共同进步。</p>
<p>##截图的实现</p>
<h3 id="1-使用adb命令截图"><a href="#1-使用adb命令截图" class="headerlink" title="1.使用adb命令截图"></a>1.使用adb命令截图</h3><p>系统是Android 2.3以上：</p>
<p><code>adb shell screencap -p xxx.png</code></p>
<p>系统是Android 4.0以上：</p>
<p><code>adb shell screenshot xxx.png</code></p>
<p>那么上面两个有什么区别呢？</p>
<p>screencap是从Android 2.3开始提供的一个系统级的截图工具，通过源码可以了解到screencap的实现方式，默认会从底层UI Surface去获取屏幕截图，如果失败则从linux kernel层的display framebuffer(/dev/graphics/fb0)去获取屏幕截图。</p>
<p>screenshot是从Android 4.0开始提供的另一个截图的工具， 通过源码可以发现screenshot则是直接读取/dev/graphics/fb0去获取屏幕的图像数据。</p>
<p>明白了这个，你就会清楚哪些电脑上的豌豆荚、腾讯手机管家等软件的屏幕截图功能是如何实现的了，其实就是调用这个这个api然后读取本地的图片而已。</p>
<pre><code>adb shell screencap -p /sdcard/flyou.png
adb pull /mnt/sdcard/output.png D:flyou.png
adb shell rm /sdcard/flyou.png
</code></pre><p>首先是调用系统截图命令将图片保存到sd卡下，然后调用adb pull将sd卡上的截图给拉出，最后删除本地文件。</p>
<p>需要注意的是，上面的命令在电脑上操作adb命令进行截图，手机是不需要root权限的，但是如果在手机上在手机上是需要的。</p>
<pre><code>public void shortScreen(String filepath){
Process process = null;
try{
process = Runtime.getRuntime().exec(&quot;su&quot;);
PrintStream outputStream = null;
try {
    outputStream = new PrintStream(new BufferedOutputStream(process.getOutputStream(), 8192));
    outputStream.println(&quot;screencap -p &quot; + filePath);
    outputStream.flush();
}catch(Exception e){
    Log.e(TAG, e);
} finally {
    if (outputStream != null) {
        outputStream.close();
    }
}
process.waitFor();
}catch(Exception e){
Log.e(TAG, e);
}finally {
if(process != null){
    process.destroy();
}
}
}
</code></pre><p>在手机端需要执行如上代码便可执行adb命令截图。<br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7qvwenwrkj20o50c2n04.jpg" alt=""></p>
<h3 id="2-使用android系统自带的截图"><a href="#2-使用android系统自带的截图" class="headerlink" title="2.使用android系统自带的截图"></a>2.使用android系统自带的截图</h3><p>在android系统中，大多数的截屏快捷键都是“音量-” 加上电源键实现的，当然也有一些特殊的机型是不一样的。</p>
<p>虽然，我们不能在开发中这个使用这个api，但是我们可以通过源码来看看它是如何是实现的。</p>
<p>Android源码中对按键的捕获位于文件PhoneWindowManager.java（alps\frameworks\base\policy\src\com\android\internal\policy\impl）中，这个类处理所有的键盘输入事件，其中函数interceptKeyBeforeQueueing（）会对常用的按键做特殊处理。以nexus5 和小米5为例，是同时按电源键和音量下键来截屏，那么在这个函数中我们会看到这么两段代码：</p>
<pre><code>.......
 case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE: {
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (isScreenOn &amp;&amp; !mVolumeDownKeyTriggered
                            &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                        mVolumeDownKeyTriggered = true;
                        mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
......

        case KeyEvent.KEYCODE_POWER: {
            result &amp;= ~ACTION_PASS_TO_USER;
            if (down) {
                if (isScreenOn &amp;&amp; !mPowerKeyTriggered
                        &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                    mPowerKeyTriggered = true;
                    mPowerKeyTime = event.getDownTime();
                    interceptScreenshotChord();
                }
......

//以下代码是对按键处理的判断
 private void interceptScreenshotChord() {
    if (mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; !mVolumeUpKeyTriggered) {
        final long now = SystemClock.uptimeMillis();
        if (now &lt;= mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS
                &amp;&amp; now &lt;= mPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) {
            mVolumeDownKeyConsumedByScreenshotChord = true;
            cancelPendingPowerKeyAction();

            mHandler.postDelayed(mScreenshotChordLongPress,
                        ViewConfiguration.getGlobalActionKeyTimeout());
        }
    }
}
</code></pre><p>系统截图的实现：</p>
<pre><code>private final Runnable mScreenshotChordLongPress = new Runnable() {
    public void run() {
        takeScreenshot();
    }
};

//如下为takeScreenshot()的代码
private void takeScreenshot() {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;,
                &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw())
                        msg.arg1 = 1;
                    if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw())
                        msg.arg2 = 1;
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    }
                }
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {}
        };
        if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
</code></pre><p>可以看到这个函数使用AIDL绑定了service服务到”com.android.systemui.screenshot.TakeScreenshotService”，并处理子线程返回的截图结果。</p>
<p>PS：android系统内部真的有好多实现都是靠的handler和message</p>
<pre><code>public class TakeScreenshotService extends Service {
private static final String TAG = &quot;TakeScreenshotService&quot;;

private static GlobalScreenshot mScreenshot;

private Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                final Messenger callback = msg.replyTo;
                if (mScreenshot == null) {
                    mScreenshot = new GlobalScreenshot(TakeScreenshotService.this);
                }
                mScreenshot.takeScreenshot(new Runnable() {
                    @Override public void run() {
                        Message reply = Message.obtain(null, 1);
                        try {
                            callback.send(reply);
                        } catch (RemoteException e) {
                        }
                    }
                }, msg.arg1 &gt; 0, msg.arg2 &gt; 0);
        }
    }
};

@Override
public IBinder onBind(Intent intent) {
    return new Messenger(mHandler).getBinder();
}
}
</code></pre><p>最终调用，takeScreenshot获取屏幕截图</p>
<pre><code>/**
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) {
    // We need to orient the screenshot correctly (and the Surface api seems to take screenshots
    // only in the natural orientation of the device :!)
    mDisplay.getRealMetrics(mDisplayMetrics);
    float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};
    float degrees = getDegreesForRotation(mDisplay.getRotation());
    boolean requiresRotation = (degrees &gt; 0);
    if (requiresRotation) {
        // Get the dimensions of the device in its native orientation
        mDisplayMatrix.reset();
        mDisplayMatrix.preRotate(-degrees);
        mDisplayMatrix.mapPoints(dims);
        dims[0] = Math.abs(dims[0]);
        dims[1] = Math.abs(dims[1]);
    }

    // Take the screenshot
    mScreenBitmap = Surface.screenshot((int) dims[0], (int) dims[1]);
    if (mScreenBitmap == null) {
        notifyScreenshotError(mContext, mNotificationManager);
        finisher.run();
        return;
    }

    if (requiresRotation) {
        // Rotate the screenshot to the current orientation
        Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(ss);
        c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
        c.rotate(degrees);
        c.translate(-dims[0] / 2, -dims[1] / 2);
        c.drawBitmap(mScreenBitmap, 0, 0, null);
        c.setBitmap(null);
        mScreenBitmap = ss;
    }

    // Optimizations
    mScreenBitmap.setHasAlpha(false);
    mScreenBitmap.prepareToDraw();

    // Start the post-screenshot animation
    startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,
            statusBarVisible, navBarVisible);
}
</code></pre><p>最终得到Surface.screenshot（）方法，该方法属于native 层的方法，我们已经无法对代码进行查看，但是通过该方法</p>
<pre><code>public static native Bitmap screenshot(int width, int height);
</code></pre><p>我们可以看出，底层实际上是接受了一个图片的宽高，最终给我们返回一个半成品的bitmap，然后在java层我们再对图片进行一系列的操作。</p>
<h3 id="3-在自己的应用中实现截图操作"><a href="#3-在自己的应用中实现截图操作" class="headerlink" title="3.在自己的应用中实现截图操作"></a>3.在自己的应用中实现截图操作</h3><p>上面说了好多应用之外截图方式的实现，那么如果我们想要在我们的app中实现截图功能，我们该如何实现呢？</p>
<pre><code>public class ScreenShot {   

// 获取指定Activity的截屏，保存到png文件   
private static Bitmap takeScreenShot(Activity activity，String fileName){   


//View是你需要截图的View   
View view = activity.getWindow().getDecorView();   
view.setDrawingCacheEnabled(true);   
view.buildDrawingCache();   
Bitmap b1 = view.getDrawingCache();  
view.destroyDrawingCache();   
savePic(b1,fileName)
}   


//保存到sdcard   
private static void savePic(Bitmap b,String strFileName){   
FileOutputStream fos = null;   
try {   
fos = new FileOutputStream(strFileName);   
if (null != fos)   
{   
b.compress(Bitmap.CompressFormat.PNG, 90, fos);   
fos.flush();   
fos.close();   
}   
} catch (FileNotFoundException e) {   
e.printStackTrace();   
} catch (IOException e) {   
e.printStackTrace();   
}   
}   
}  
</code></pre><p><strong>截图效果如下：</strong><br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxsmer3gj20u01hcjvv.jpg" alt=""></p>
<p>如果不想要状态栏只需要对获得bitmap进行操作，截去状态栏的高度即可</p>
<p><strong>相关代码如下：</strong></p>
<pre><code>//获取状态栏高度   
Rect frame = new Rect();   
activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);   
int statusBarHeight = frame.top;   
System.out.println(statusBarHeight);   

//获取屏幕长和高   
int width = activity.getWindowManager().getDefaultDisplay().getWidth();   
int height = activity.getWindowManager().getDefaultDisplay().getHeight();   


//去掉标题栏    
Bitmap newBitmap = Bitmap.createBitmap(b1, 0, statusBarHeight, width, height - statusBarHeight); 
</code></pre><p>这样就可以获取对应没有状态栏的图片。<br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxz0kw8uj20u01f9430.jpg" alt=""><br>但是，这样往往不能满足我们在开发中的需求，往往在开发中产品会要求我们只截去内容部分的图片，那么这时我们该怎么做呢？</p>
<p>其实方法也是很多，比如对<strong>先截去屏幕，然后对制定区域进行裁剪</strong>，<strong>使用自定义控件</strong>，其实原理也很简单，先绘制背景在确定子View的位置，再回执子View即可。但是呢这里也有几个比较简单的方法，<strong>直接获取相应布局的父布局，然后调用相关方法进行截取并保存即可</strong>。</p>
<p>下面只给出第三种方式的实现方法，如果对上面两种实现方法感兴趣的话自己可以了解下。</p>
<pre><code>View view = findViewById(R.id.share_layout);
Bitmap bmp = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
view.draw(new Canvas(bmp));
</code></pre><p>此时取到的BitMap就是你的目标布局的图片，但是使用此方法必须在数据加载完毕后使用，不然获取的截图可能是空白的，还有bitmap使用完需要记得<strong>recycle</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rog43thzj20p011iad9.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实现屏幕截图的方法有很多，实现的方法也是多种多样的，希望大家根据自己的需要都能够找到适合自己的方法，如果写的有什么纰漏的地方，欢迎大家指正讨论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定下几个小目标]]></title>
      <url>http://flyou.ren/2016/09/05/%E5%AE%9A%E4%B8%8B%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7iqwwww7yj20h809kdgu.jpg" alt=""></p>
<p>转眼已经毕业整整三个月了，一直没有好好静下来写些东西了，最近看见朋友圈都在定目标，再加上今天有空所以就也写点东西吧。</p>
<h3 id="1-瘦下来"><a href="#1-瘦下来" class="headerlink" title="1.瘦下来"></a>1.瘦下来</h3><p>自己真的是越来越胖了，自己都受不了自己了，已经从以前的120飙升到了160，哦买噶，再不瘦我真的就要变成胖子了，我不要，我不要！！</p>
<p>从今天起，每天坚持锻炼，晚上少吃点可好？当然120不是我的目标体重，要不然又要被老妈催着增肥了！！那么就140吧？</p>
<h3 id="2-沉下去"><a href="#2-沉下去" class="headerlink" title="2.沉下去"></a>2.沉下去</h3><p>毕业是毕业了，但是我认为我们都不能因为自己角色的改变而去中断学习，学习应该是贯穿每个人一生的事情。我还是希望自己能够把自己定位为一个学生，对啊学生真好。</p>
<ul>
<li>在最近的一段时间尽量把java基础和数据库操作回顾一遍</li>
<li>学习前端以及node.js相关知识，如果可以的话尽量多看看PHP吧</li>
<li>掌握几门其他语言，python和lua等</li>
<li>至于android，我还是希望自己能多学习，多记录</li>
</ul>
<h3 id="3-来写作"><a href="#3-来写作" class="headerlink" title="3.来写作"></a>3.来写作</h3><p>写作可以让我们更加巩固自己的知识，是自己的知识体系更加的清晰并完善，只有不断的写作和记录自己才会知道自己还有那些不了解，自己还有那些需要去学习。</p>
<p>当然，我觉得我平时也不会仅仅去写些关于技术的相关的，我更会在自己的博客中分享自己的心得以及对某一件事的看法，因为写作也是使人放松的一种方法，那么我们为什么不坚持呢？</p>
<h3 id="4-去旅游"><a href="#4-去旅游" class="headerlink" title="4.去旅游"></a>4.去旅游</h3><p>2016年已经过去了一大半，说好的出玩计划因为各种原因都没有实现，最近心里也是有许多的额事情，感觉心得压力很大，真的觉得自己必须要出去转转了，至于目的地是哪，我觉得都是可以的，厦门？杭州？南京？或者是西藏吧。</p>
<p>一个人或者约三两个好友感觉去哪里都是不错的，是的，是时候出去转转了呢！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，我的小目标定好了，希望自己的目标能够在新年前实现吧，这样我才好写我的年终总结啊。</p>
<p>于：2016/9/5 15:59:15 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android夜间模式浅析]]></title>
      <url>http://flyou.ren/2016/08/18/android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="几种实现夜间模式的方式"><a href="#几种实现夜间模式的方式" class="headerlink" title="几种实现夜间模式的方式"></a>几种实现夜间模式的方式</h2><h3 id="1：修改theme，重启activity"><a href="#1：修改theme，重启activity" class="headerlink" title="1：修改theme，重启activity"></a>1：修改theme，重启activity</h3><p>使用时定义不同的主题，通过切换主题重启acticity的方式完成切换</p>
<p><strong>优点</strong>：正儿八经的夜间模式，配色看着舒服</p>
<p><strong>缺点</strong>：图片刺眼、闪屏</p>
<h3 id="2：覆盖一定透明度的View"><a href="#2：覆盖一定透明度的View" class="headerlink" title="2：覆盖一定透明度的View"></a>2：覆盖一定透明度的View</h3><p>使用一个带黑色带透明度的View，盖在现有的activity上，效果类似你带上墨镜，看着太阳不刺眼。</p>
<p><strong>优点</strong>：不用重启activity，不闪屏；加上透明度过渡动画，模式之间切换非常舒服，解决了1中，白底图片依旧刺眼的问题。</p>
<p><strong>缺点</strong>：配色没变化，就算带上墨镜，白天依旧是白天。</p>
<h3 id="3：使用动态换肤方案"><a href="#3：使用动态换肤方案" class="headerlink" title="3：使用动态换肤方案"></a>3：使用动态换肤方案</h3><p>一般借助于第三方库完成换肤，如：<br><a href="https://github.com/hongyangAndroid/ChangeSkin" target="_blank" rel="external">https://github.com/hongyangAndroid/ChangeSkin</a><br><a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">https://github.com/fengjundev/Android-Skin-Loader</a></p>
<p><strong>优点</strong>：不用重启activity，不闪屏；可以为程序提供多种皮肤方案不局限于夜间/白天模式。</p>
<p><strong>缺点</strong>：在制作方面代价过大，侵入性较强，需要以来第三方库完成，可靠性不能得到保证。</p>
<h3 id="4：使用-Support-Library-23-2-0-DayNight主题实现"><a href="#4：使用-Support-Library-23-2-0-DayNight主题实现" class="headerlink" title="4：使用 Support Library 23.2.0 DayNight主题实现"></a>4：使用 Support Library 23.2.0 DayNight主题实现</h3><p><strong>优点</strong>：Google自家产品，可靠性高，配置简单，省心省力，在仅仅需要实现夜间/日间模式的应用内强烈推荐。</p>
<p><strong>缺点</strong>：不支持多皮肤切换算吗？貌似今天只谈夜间模式的实现……。</p>
<h2 id="使用DayNight主题来实现夜间模式"><a href="#使用DayNight主题来实现夜间模式" class="headerlink" title="使用DayNight主题来实现夜间模式"></a>使用DayNight主题来实现夜间模式</h2><p>对于前两种方式来说，从实现来说是不困难的但是对用户的体验在一定程度上是很不好的，一个需要重启activity，一个配色无法改变都是我们不推荐的。</p>
<p>当然第三种方式市面上也有比较成熟的第三方库来完成程序的换肤，但是对于单单需要夜间模式的应用来说未免有些大材小用了。</p>
<p>今天我们使用DayNight主题来实现换肤功能。</p>
<h3 id="1-定义DayNight主题，及相关属性"><a href="#1-定义DayNight主题，及相关属性" class="headerlink" title="1.定义DayNight主题，及相关属性"></a>1.定义DayNight主题，及相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;</div><div class="line">      &lt;!-- Customize your theme here. --&gt;</div><div class="line">      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</div><div class="line"> 		&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>可以在主题中定义一些颜色尺寸等属性，在vlaues的colors.xml 声明color属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>在res下面创建values-night文件夹，创建colors.xml声明color属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#1f2023&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#18181a&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<h3 id="2-为程序设置初始模式"><a href="#2-为程序设置初始模式" class="headerlink" title="2.为程序设置初始模式"></a>2.为程序设置初始模式</h3><p>程序中进行主题的初始化。你需要调用 AppCompatDelegate.setDefaultNightMode() ，它有四个参数：</p>
<p>MODE_NIGHT_NO. 使用亮色（light）主题</p>
<p>MODE_NIGHT_YES. 使用暗色（dark）主题</p>
<p>MODE_NIGHT_AUTO. 根据当前时间自动切换 亮色（light）/暗色（dark）主题</p>
<p>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统，通常为 MODE_NIGHT_NO</p>
<p>如在Application中进行初始化：</p>
<pre><code>public class MyApplication extends Application {
static {
    AppCompatDelegate.setDefaultNightMode(
            AppCompatDelegate.MODE_NIGHT_NO);
}

@Override
public void onCreate() {
    super.onCreate();
}

}
</code></pre><h3 id="3-在初始化时就切换夜间模式"><a href="#3-在初始化时就切换夜间模式" class="headerlink" title="3.在初始化时就切换夜间模式"></a>3.在初始化时就切换夜间模式</h3><pre><code> public class MyActivity extends AppCompatActivity {
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
        // Set the local night mode to some value
        getDelegate().setLocalNightMode(
                AppCompatDelegate.MODE_NIGHT_...);
        // 调用 recreate() 使设置生效
        recreate();
    }
} }
</code></pre><h3 id="4-如何获取当前主题的状态"><a href="#4-如何获取当前主题的状态" class="headerlink" title="4.如何获取当前主题的状态"></a>4.如何获取当前主题的状态</h3><pre><code>int currentNightMode = getResources().getConfiguration().uiMode
    &amp; Configuration.UI_MODE_NIGHT_MASK;

case Configuration.UI_MODE_NIGHT_NO:

case Configuration.UI_MODE_NIGHT_YES:

case Configuration.UI_MODE_NIGHT_UNDEFINED:
</code></pre><p>可以通过上面面的几种状态来进行相应的操作如：<br>```<br> private void judeStatusOfDayNight() {</p>
<pre><code>    int currentNightMode = getResources().getConfiguration().uiMode
            &amp; Configuration.UI_MODE_NIGHT_MASK;
    switch (currentNightMode) {
        case Configuration.UI_MODE_NIGHT_NO:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_YES);


            break;
        case Configuration.UI_MODE_NIGHT_YES:
             getDelegate().setDefaultNightMode(
                AppCompatDelegate.MODE_NIGHT_NO);
            break;
        case Configuration.UI_MODE_NIGHT_UNDEFINED:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_AUTO);
            break;
    }
    // 调用 recreate() 使设置生效
    recreate();
}
</code></pre><p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f6y5w7d0npg20dc0m841f.gif" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，这仅仅是一个简单的例子，如果涉及图片你需要创建drawable-night文件夹。</p>
<p>对于一些按钮的颜色背景都需要做相应的处理，当然处理起来还是很简单的。</p>
<p>那么现在为你的程序加上夜间模式吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://flyou.ren/2016/08/11/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="我的Blog发展史"><a href="#我的Blog发展史" class="headerlink" title="我的Blog发展史"></a>我的Blog发展史</h2><p>从12年开始写博客到现在，自己也接触了很多的博客，比如博客园，CSDD等，再到后来自己又接触到了WordPress，在上面写了一段时间总体来说是不错的，但是相应速度总是觉得有点慢。<br>于是便有了现在的博客，相比于以前用过的Blog，给予node.js 使其的响应速度可以说是相当的快，再加上MarkDown语法的支持，使得用它写作简直爽到飞，好吧就从今天开始入手吧。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>处于便于查看的目的，下面的提示命令就不删除了，哈哈。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
