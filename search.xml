<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[关于RecycleView你需要知道的之「ItemDecoration」]]></title>
      <url>http://flyou.ren/2017/09/05/%E5%85%B3%E4%BA%8ERecycleView%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%8B%E3%80%8CItemDecoration%E3%80%8D/</url>
      <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>其实本不打算写RecycleView相关的东西，因为周围一直围绕着RecycleView好用吗？RecycleView简单吗？RecycleView能实现这个功能？的疑问，以及在疑问中坚守ListView的守门员。所以，这个关（Kan）我（bu）什(xia)么(qu)事(le)。</p>
<blockquote>
<p>阅读本文大概需要10分钟，当然也可能是10秒。</p>
</blockquote>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h2><p>以下就是RecycleView的基本用法</p>
<ol>
<li>在xml中引入RecycleView</li>
<li>初始化控件</li>
<li>设置LayoutManager</li>
<li>设置‘分割线’（可选）</li>
<li>设置Item动画（可选）</li>
<li>设置Adapter<center><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fj8os1jjejj308c08ct8r.jpg" alt=""><br></center>

</li>
</ol>
<p>是的就是这个样子，不然你还想怎么样？我让我把别人都写过的东西再写一遍？别闹了，乖，我反手扔给你一个链接怎么样？</p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="external">Android RecyclerView 使用完全解析 体验艺术般的控件</a></p>
<p>鸿洋大婶将的很好，我再写也不是没有必要，主要是我懒啊。。。</p>
<blockquote>
<p>阅读本文之前，裂墙建议先阅读上述文章</p>
</blockquote>
<h2 id="3-ItemDecoration-≠-Split-Line"><a href="#3-ItemDecoration-≠-Split-Line" class="headerlink" title="3 ItemDecoration ≠ Split Line"></a>3 ItemDecoration ≠ Split Line</h2><p>是谁告诉你们Decoration是分割线的意思了？为什么一提到addItemDecoration（）你们就觉得是添加分割线呢？再看看网上的文章也都是分割线，为了科普下Decoration的真是意思我特地的Google了下</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fj9ladixjfj30hq06dwen.jpg" alt=""></p>
<p>人家是装饰的意思有没有，并不是单单的分割线那么简单，造吗？这是知识点，知识点！！</p>
<p>好吧，咱们还是去看看官网上的解释吧</p>
<p>An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter’s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and ?more.</p>
<p>ItemDecoration允许应用程序从适配器的数据集中向特定项目视图添加特殊图形和布局偏移量。 这可以用于在项目，高亮度，视觉分组边界等之间绘制分隔符等等。</p>
<h3 id="3-1-ItemDecoration基本流程"><a href="#3-1-ItemDecoration基本流程" class="headerlink" title="3.1 ItemDecoration基本流程"></a>3.1 ItemDecoration基本流程</h3><p>要先绘制自己的装饰器，我们需要了解下ItemDecoration的方法。<br>ItemDecoration包括三个方法。</p>
<p><strong>getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)</strong><br><strong>onDraw(Canvas c, RecyclerView parent, State state)</strong><br><strong>onDrawOver(Canvas c, RecyclerView parent, State state)</strong></p>
<p><strong>getItemOffsets()</strong><br><br>负责对RecycleView每一个Item上下左右偏移量的测量，什么意思也就是你的每个子View距离上下左右有多少间隔。</p>
<p><strong>onDraw()</strong><br><br>见名知意，就是对你想要装饰的绘制，canvas对象都给你了，你想画什么还不都是你的事？</p>
<p><strong>onDrawOver()</strong><br><br>与onDraw()类似都是负责装饰的绘制，但是这个方法可以绘制在你ItemView上面，具体什么意思，下面会具体介绍。</p>
<p><strong>注意</strong></p>
<p>decoration 的 onDraw，child view 的 onDraw，decoration 的 onDrawOver，这三者是依次发生的<br><br>在 onDraw绘制到 canvas 上，而这个绘制范围可以超出在 getItemOffsets 中设置的范围，但由于 decoration 是绘制在 child view 的底下，所以并不可见，但是会存在 overdraw<br><br>onDrawOver 是绘制在最上层的，所以它的绘制位置并不受限制</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fj9p0l0f5fj30p00gojrq.jpg" alt=""></p>
<p>正如上文和上图所示，onDraw()的绘制区域是由getItemOffsets测量的结果决定，由于绘制的先后性，RecycleView ItemView 的onDraw方法会覆盖掉getItemOffsets测量以外的区域。由于onDrawOver在最后进行绘制，所以onDrawOver的绘制返回不受限制。</p>
<h3 id="3-2-getItemOffsets"><a href="#3-2-getItemOffsets" class="headerlink" title="3.2 getItemOffsets()"></a>3.2 getItemOffsets()</h3><p>首先我们先来具体看下getItemOffsets()，getItemOffsets会让你去决定上下左右的偏移尺寸，如下图所示。</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fj9o0kragzj30p00gowen.jpg" alt=""></p>
<p>上下左右这个偏移的尺寸，而这个尺寸，被计入了 RecyclerView 每个 item view 的 padding 中。</p>
<p>为了验证上面的结论咱们写个例子死一死啊<br><br><br>首先我们创建我们自己的Decoration继承ItemDecoration，先只覆写其中的getItemOffsets方法，然后使得ItemView的上下左右都有10像素的偏移。</p>
<pre><code>public class SimpleDecoration extends RecyclerView.ItemDecoration {
            @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
    super.getItemOffsets(outRect, view, parent, state);
    outRect.set(10, 10, 10, 10);
    }
}
</code></pre><p>把我们自定义的ItemDecoration设置给RecycleView</p>
<pre><code>public class SimpleDecorationActivity extends AppCompatActivity {
private RecyclerView recycleView;
private List&lt;String&gt; dataList = new ArrayList&lt;&gt;();
        @Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_simple_demo);
for (int i = 1; i &lt; 80; i++) {

dataList.add(&quot;第&quot; + i + &quot;个&quot;);
}
this.recycleView = (RecyclerView) findViewById(R.id.recycleView);
recycleView.setLayoutManager(new LinearLayoutManager(this));
SimpleDecoration headerDecoration = new SimpleDecoration();
recycleView.addItemDecoration(headerDecoration);
recycleView.setAdapter(new RecyclerAdapter(this, dataList));
        }
}
</code></pre><p>来嘛，这就是见证奇迹的时刻，啊嘿</p>
<center><br><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fj9pksf46oj30dc0npmyo.jpg" alt=""><br></center>

<p>纳尼？说好的效果呢？为啥我看不到？</p>
<p>那是因为ItemView的背景和activity的背景都是白色，来我们给activity布局加个背景颜色再试试</p>
<center><br><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fjazxoa15oj30dc0np75e.jpg" alt=""><br></center>

<p>可以看到RecycleView的ItemView的上下左右都加上了间隔（同理，如果只设置下面的Offset，只有下面才会有背景颜色），这个颜色其实是背景的颜色，并不是我们绘制的装饰，因为我们还没调用任何的绘制函数。</p>
<p><strong>可以看到，getItemOffsets()其实就是对ItemView设置Padding，为OnDraw提供绘制控件</strong></p>
<h3 id="3-3-onDraw"><a href="#3-3-onDraw" class="headerlink" title="3.3 onDraw()"></a>3.3 onDraw()</h3><p>熟悉了getItemOffsets()我们接下来来看看装饰的绘制</p>
<pre><code>   @Override
public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {}
</code></pre><p>可以看到onDraw()中有三个参数，一个Canvas绘制的画布，一个RecyclerView和一个存储RecyclerView状态的State（recycle的滑动状态，位置等，暂时用不到）对象。</p>
<p>由于我们获得了Canvas对象，所以我们可以画任意我们想要的，那么就简单画一个分隔线吧</p>
<p>首先获得绘制范围：</p>
<pre><code>private float driverHeight=10f;
private Paint paint;
public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
    super.getItemOffsets(outRect, view, parent, state);
    outRect.set(0,0,0,driverHeight);//只设置底部offset
    }
</code></pre><p>在构造方法中声明Paint对象</p>
<pre><code>      public SimpleDecoration() {
    this.paint=new Paint();
    paint.setColor(Color.BLUE);
    paint.setAntiAlias(true);
    paint.setStyle(Paint.Style.FILL);
}
</code></pre><p>在onDraw方法中为每个ItemView绘制分割线</p>
<pre><code> @Override
public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDraw(canvas, parent, state);

    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);
        int top = view.getBottom();
        float bottom = top + driverHeight;
        canvas.drawRect(left,top,right,bottom,paint);
    }
}
</code></pre><p><strong>备注：</strong>这里的onDraw绘制是针对于每个ItemView的绘制，需要你自己根据自己的需求完成绘制，而getItemOffsets里面设置的间隔是针对于每个Item，所以这里需要对每一个item View进行绘制。</p>
<p>其实，上面的代码很简单，就是在每一个Item的底部画了一个长方形而已。</p>
<center><br><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fjb1l21r0ej30dc0np75g.jpg" alt=""><br></center>

<p>但是这个仅仅是简单的演示，因为这仅仅是针对竖向的LinearLayoutManager而言的，针对于横向的不行了，中间分割线的样式也不能随意定制，下面就贴出一个比较完善的分割线Decoration</p>
<pre><code>Public class DividerListItemDecoration extends RecyclerView.ItemDecoration {
private static final int[] ATTRS = new int[]{
        android.R.attr.listDivider
};

public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;

public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;

private Drawable mDivider;

private int mOrientation;

public DividerListItemDecoration(Context context, int orientation) {
    final TypedArray a = context.obtainStyledAttributes(ATTRS);
    mDivider = a.getDrawable(0);
    a.recycle();
    setOrientation(orientation);
}

public DividerListItemDecoration(Context context, int orientation, int drawableId) {
    mDivider = ContextCompat.getDrawable(context, drawableId);
    setOrientation(orientation);
}

public void setOrientation(int orientation) {
    if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {
        throw new IllegalArgumentException(&quot;invalid orientation&quot;);
    }
    mOrientation = orientation;
}

//画线 &gt; 就是画出你想要的分割线样式
@Override
public void onDraw(Canvas c, RecyclerView parent) {
    if (mOrientation == VERTICAL_LIST) {
        drawVertical(c, parent);
    } else {
        drawHorizontal(c, parent);
    }

}


public void drawVertical(Canvas c, RecyclerView parent) {
    final int left = parent.getPaddingLeft();
    final int right = parent.getWidth() - parent.getPaddingRight();

    final int childCount = parent.getChildCount();
    for (int i = 0; i &lt; childCount; i++) {
        final View child = parent.getChildAt(i);

        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                .getLayoutParams();
        final int top = child.getBottom() + params.bottomMargin;
        final int bottom = top + mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(c);
    }
}

public void drawHorizontal(Canvas c, RecyclerView parent) {
    final int top = parent.getPaddingTop();
    final int bottom = parent.getHeight() - parent.getPaddingBottom();

    final int childCount = parent.getChildCount();
    for (int i = 0; i &lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                .getLayoutParams();
        final int left = child.getRight() + params.rightMargin;
        final int right = left + mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(c);
    }
}

//设置条目周边的偏移量
@Override
public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {
    if (mOrientation == VERTICAL_LIST) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}
}
</code></pre><p>其实，代码依旧很简单，只不过让用户传入了布局的方向和要绘制的图案，当然可以实现和上面一样的效果，这里就不再贴图了。</p>
<p><a href="https://github.com/flyou/RecycleViewDecoration/blob/master/library/src/main/java/com/flyou/library/decoration/DividerListItemDecoration.java" target="_blank" rel="external">ListItemDecoration on Github</a></p>
<p>关于GridItemDecoration的写法和ListItemDecoration类似不再贴代码了，直接反手又给你了一个地址。</p>
<p><a href="https://github.com/flyou/RecycleViewDecoration/blob/master/library/src/main/java/com/flyou/library/decoration/DividerGridItemDecoration.java" target="_blank" rel="external">GridItemDecoration on Github</a></p>
<p>那么有人肯定要问了，逼逼了这么多，这不还是分割线吗？别急啊，下面就开始装逼，不对，不对，是说说其他的。</p>
<center><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fj8qo1om43j306y06ywef.jpg" alt=""><br></center>

<p>上面我们已经提到了，onDraw方法给我们了Canvas对象，那么我们配合getItemOffsets真的是想画什么就画什么啊</p>
<p>比如，时间轴效果，物流流转效果。</p>
<center><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fjb38utq79j30dc0npq41.jpg" alt=""><br></center>

<p>原谅我比较懒，原谅我放荡不羁爱自由，界面比较丑，大家可以充分发挥下想象力</p>
<p>怎么样？是是觉得惊艳了很多？</p>
<center><br><br><img src="http://ww2.sinaimg.cn/large/0060lm7Tly1fj8qo1p2tyj30du0af74i.jpg" alt=""><br></center>

<p>好啦，好啦不闹了……说说怎么实现吧，那么你觉得应该怎么实现，先不说今天怎么做，就说常规的肯定是在ItemView的布局文件里实现，其实我想说布局复杂点的话布局文件真的不好写……<br><br><br>但是，如果使用ItemDecoration就不一样了，完全不用考虑ItemView里面有什么，布局怎么样。<br>具体怎么做呢？咱们先看看下面的图：</p>
<center><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fjb45irvgjj30p00gojrq.jpg" alt=""><br></center>

<p>可以看到左边是内容我们需要绘制的区域，右边是内容区域，我们主要是在左侧进行view的绘制就ok了，分隔线怎么实现上面已经讲过了就不在具体赘述了。</p>
<p>首先我们需要定义分割线的高度（offsetBottom），和左侧宽度（offsetsLeft）圆的半径以及画笔对象如下：</p>
<pre><code>private float driverHeight=2f;
private float offsetsLeft=200f;
private float circleRadius=30f;
private Paint paint;
</code></pre><p>当然这些参数可以从构造函数或者其他方法传入，这里仅仅为了演示效果不再写了（对，还是懒……）。</p>
<p>构造方法初始化Paint对象</p>
<pre><code>public StepLineDecoration() {
    this.paint=new Paint();
    paint.setColor(Color.BLUE);//设置绘制颜色
    paint.setAntiAlias(true);//抗锯齿
    paint.setStyle(Paint.Style.FILL);//填充样式
}
</code></pre><p>设置onDraw的绘制区域，设置itemView的左侧偏移和底部分割线的偏移</p>
<pre><code> @Override
public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {

    super.getItemOffsets(outRect, view, parent, state);
        outRect.set((int) offsetsLeft,0,0, (int) driverHeight);
}
</code></pre><p>好的吧，接下来就是左侧和下部分割线的绘制</p>
<pre><code>@Override
public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDraw(canvas, parent, state);

    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);
        int top = view.getBottom();
        float bottom = top + driverHeight;
        paint.setStyle(Paint.Style.FILL);
        canvas.drawRect(left,top,right,bottom,paint);//画分割线

        paint.setStrokeWidth(5);//设置竖线的宽度
        paint.setStyle(Paint.Style.STROKE);//填充类型空心
        float circleX=left+offsetsLeft/2;//圆心的x坐标
        float circleY=view.getTop()+(view.getBottom()-view.getTop())/2;//圆心的x坐标

        float topLineStartX=circleX;//上部线条起始X坐标
        float topLineStartY=view.getTop();//上部线条起始Y坐标

        float topLineEndX=circleX;//上部线条终止X坐标
        float topLineEndY=circleY-circleRadius;//上部线条终止Y坐标

        float bottomLineStartX=circleX;
        float bottomLineStartY=circleY+circleRadius;

        float bottomLineEndX=circleX;
        float bottomLineEndY=view.getBottom();

        paint.setStrokeCap(Paint.Cap.ROUND);//线条头类型
        canvas.drawLine(topLineStartX,topLineStartY,topLineEndX,topLineEndY,paint);//画上部线条
        canvas.drawLine(bottomLineStartX,bottomLineStartY,bottomLineEndX,bottomLineEndY,paint);//画底部线条
        canvas.drawCircle(circleX,circleY,circleRadius,paint);//画圆圈

    }
}
</code></pre><p>绘制的流程也很简单，我们首先绘制底部的分割线，然后计算圆心位置线段的起始位置并绘制线段和圆。</p>
<p>同理，我们可以绘制出许多我们想要的效果，如排名效果：</p>
<center><br><br><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fjb4vnj7ysj30dc0npgnf.jpg" alt=""><br></center>

<p>原理和上面类似，简单的额绘制而已，获取圆、测量文字、绘制文字。</p>
<pre><code> @Override
public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDraw(canvas, parent, state);

    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);
        int position = parent.getChildAdapterPosition(view);

        int top = view.getBottom();
        float bottom = top + driverHeight;
        paint.setStyle(Paint.Style.FILL);
        canvas.drawRect(left, top, right, bottom, paint);
        if (position &lt; 3) {
            rankPaint.setColor(Color.RED);
        } else {
            rankPaint.setColor(Color.GRAY);
        }
        paint.setStrokeWidth(5);
        float circleX = left + offsetsLeft / 2;
        float circleY = view.getTop() + (view.getBottom() - view.getTop()) / 2;
        paint.setStrokeCap(Paint.Cap.ROUND);
        Rect bounds = new Rect();
        String rank = String.valueOf(position+1);
        textPaint.getTextBounds(rank, 0, rank.length(), bounds);
        int height = bounds.height();
        int width = (int) textPaint.measureText(rank, 0, rank.length());
        canvas.drawCircle(circleX, circleY, circleRadius, rankPaint);
        canvas.drawText(rank, circleX - width / 2, circleY + height / 2, textPaint);

    }
</code></pre><h3 id="3-4-onDrawOver"><a href="#3-4-onDrawOver" class="headerlink" title="3.4 onDrawOver()"></a>3.4 onDrawOver()</h3><p>上面已经介绍过了，onDrawOver可以超过getItemOffsets测量的绘制区域，也就是你说他可以覆盖在ItemView上。那么它有什么用？</p>
<blockquote>
<p>其实用途也是很多的举个栗子吧还是，比如说ListView中常见的悬浮头效果，在ListView中常见的实现方式都是复写ondraw方法实现的在super.ondraw()方法下绘制上自己想要的头，实现起来可以说是非常的麻烦，但是如果在RecycleView中使用ItemDecoration可以很轻松的实现。</p>
</blockquote>
<center><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fjb887e4ipg30dc0npx6q.gif" alt=""><br></center>

<p>由于要实现浮选效果，onDraw方法自然就没办法满足了，使用onDrawOver方法可以很轻松实现这个效果。</p>
<p>定义针对于头的Bean<br>    public class StickyHeadeBean {<br>    private String title;<br>    private boolean isFirst;//列表第一个<br>    private boolean isTeamFirst;//是否是组内第一个<br>    private boolean isTeamLast;//是否是组内最后一个<br>    }<br>首先我们为绘制获得Offset</p>
<p>如果是组内第一个元素则设置topOffset为header的高度，否则则为分割线的高度</p>
<pre><code>    @Override
public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {

    super.getItemOffsets(outRect, view, parent, state);
    if (dataList.get(parent.getChildAdapterPosition(view)).isTeamFirst()) {
        outRect.set(0, (int) offsetsLeft, 0, 0);
    } else {
        outRect.set(0, (int) driverHeight, 0, 0);
    }
}
</code></pre><p><strong>onDraw</strong></p>
<p>在这里仅仅绘制分割线，头部布局在onDrawOver中统一绘制</p>
<pre><code>@Override
public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDraw(canvas, parent, state);

    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);

        if (dataList.get(parent.getChildAdapterPosition(view)).isTeamFirst()) {//头部在OndrawOver中绘制

        } else {
            int bottom = view.getTop();
            float top = bottom - driverHeight;
            canvas.drawRect(left, top, right, bottom, paint);
        }


    }
}
</code></pre><p><strong>onDrawOver</strong></p>
<p>首先我们需要知道绘制头的条件：<br>1.屏幕内第一个可见的元素<br>2.如果它不是屏幕内第一个可见的元素，但是它是组内第一个可见的元素</p>
<p>代码如下：</p>
<pre><code>@Override
public void onDrawOver(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDrawOver(canvas, parent, state);


    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);
        int childAdapterPosition = parent.getChildAdapterPosition(view);
        StickyHeadeBean stickyHeadeBean = dataList.get(childAdapterPosition);
        if (i != 0) {//不是第一个元素时，只有组内第一个才绘制
            if (stickyHeadeBean.isTeamFirst()) {
                int bottom = view.getTop();
                float top = bottom - offsetsLeft;
                drawHeader(canvas, left, right, (int) top, bottom, view);
            }
        } else {
                //第一个元素直接绘制
            int top = view.getPaddingTop();
            int bottom = (int) (top + offsetsLeft);
            drawHeader(canvas, left, right, top, bottom, view);

        }
    }
}
</code></pre><p>绘制头部的代码：</p>
<pre><code>  private void drawHeader(Canvas canvas, int left, int right, int top, int bottom, View view) {

    canvas.drawRect(left, top, right, bottom, paint);
    int textX = (int) ((right - left) / 2 - textWidth / 2);
    int textY = (int) (bottom - offsetsLeft / 2 + textHeight / 2);
    Log.d(TAG, &quot;onDraw: &quot; + textY);
    canvas.drawText(headerText, textX, textY, mTextPaint);
}
</code></pre><p>写完代码，满心欢喜地运行下</p>
<center><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fjb9e651dcg30dc0np1ky.gif" alt=""><br></center>

<p>嗯嗯，效果还不错但是，下一个头是直接盖在了上一个上面，效果并不是很优雅，所以我们需要判断元素是否是组内最后一个来把自己给推上去</p>
<pre><code> @Override
public void onDrawOver(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
    super.onDrawOver(canvas, parent, state);


    int childCount = parent.getChildCount();
    int left = parent.getPaddingLeft();
    int right = parent.getWidth() - parent.getPaddingRight();
    for (int i = 0; i &lt; childCount; i++) {
        View view = parent.getChildAt(i);
        int childAdapterPosition = parent.getChildAdapterPosition(view);
        StickyHeadeBean stickyHeadeBean = dataList.get(childAdapterPosition);
        if (i != 0) {
            if (stickyHeadeBean.isTeamFirst()) {
                int bottom = view.getTop();
                float top = bottom - offsetsLeft;
                drawHeader(canvas, left, right, (int) top, bottom, view);
            }
        } else {

            int top = view.getPaddingTop();
            //判断是否为组内最后一个，如果是，则头的位置需要随View改变
            if (stickyHeadeBean.isTeamLast()){
                int suggestTop = (int) (view.getBottom() - offsetsLeft);
                if (suggestTop&lt;top){
                    top=suggestTop;
                }

            }
            int bottom = (int) (top + offsetsLeft);
            drawHeader(canvas, left, right, top, bottom, view);

        }
    }
}
</code></pre><p>加上上面的判断，再次运行就是我们想要的效果了</p>
<p>ItemDecoration其实很简单，但是确实可以完成很多炫酷的效果，我这么帅怎么肯能骗你？</p>
<p>照例贴上代码地址 <a href="https://github.com/flyou/RecycleViewDecoration" title="点位查看" target="_blank" rel="external">点我查看</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写着，写着就写了好长，最后还是觉得分开几篇讲比较好。下篇我们看下LayoutManager</p>
<center><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fj8qo1phnvj308c08ct8q.jpg" alt=""><br></center>









]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于科学上网两三事-续]]></title>
      <url>http://flyou.ren/2017/07/20/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B8%A4%E4%B8%89%E4%BA%8B-%E7%BB%AD/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇文章中我们介绍了市面上几种番羽土啬的方式，以及如何搭建一套属于自己SS服务端，但是考虑到多种原因，很多小伙伴应该也不会那么做。</p>
<p>为啥咧？你们都去打农药了吗？你们都去约会了吗？说的跟你们真的有女朋友似得。</p>
<p>今天我们不聊这个，我们今天就是要帮懒人做件事，话说懒人番羽土啬要干嘛？<br><br>那我猜肯定是倒数第三种。</p>
<p><a href="http://ww2.sinaimg.cn/large/a15b4afegy1fhmz2ttjhoj20hi0cnjry.jpg" target="_blank" rel="external">第三种是什么</a></p>
<h3 id="有什么问题吗？"><a href="#有什么问题吗？" class="headerlink" title="有什么问题吗？"></a>有什么问题吗？</h3><p>上篇文章问题提到如何搭建自己的ss服务器，很多小伙伴提到自己搭建太麻烦，费用也是个问题</p>
<center><br><img src="http://www.rsdown.cn/d/file/p/2017-04-21/c33054adb3b0b44696d1960a35884abc.png" alt=""><br></center>

<p>但是，你还记得上一篇文章的最后，提到一个免费的代理账号的网站，但是周围很多小伙伴还是说使用起来太不方便了。</p>
<p><strong>纳尼？</strong></p>
<ol>
<li>网站上有多个账号数据，有很多个不能使用，一次次填写账号密码数据太繁琐。</li>
<li>代理账号密码数据每6个小时更新一次，更新后原账号密码数据不可用，难道我要每6个小时再重复上面的动作？</li>
</ol>
<p>仔细想了想，确实是这个样子，每次都要做重复的操作确实太不软件工程了，那么，那么就让我们洗洗睡吧。</p>
<p>开什么玩笑，问题肯定要解决啊。</p>
<h3 id="唠唠这些问题"><a href="#唠唠这些问题" class="headerlink" title="唠唠这些问题"></a>唠唠这些问题</h3><blockquote>
<p>上一节我们提到要实现这么一个工具（软件）来获取网站上的账号和密码数据到保存到本地并配置给代理软件。</p>
</blockquote>
<h4 id="1-咦，账号的获取"><a href="#1-咦，账号的获取" class="headerlink" title="1.咦，账号的获取"></a>1.咦，账号的获取</h4><p>首先我们说说怎么获取这些账号和密码数据，肯定不能再一次次手动打开这个网站去抄这些数据吧，爬虫在这个时候就显得非常好用了。</p>
<p>那么，该用什么来实现这个爬虫呢？</p>
<p>这里我采用了Jsoup来显示这个爬虫，主要是因为python的定时调度不好用（下面具体说明）</p>
<p>使用jsoup爬去这个页面的数据和python一样，写起来很简单</p>
<pre><code> public List&lt;SSBean&gt; getSSAccount() {

    Document document = null;
    try {
        document = Jsoup.connect(&quot;http://ss.ishadowx.com/&quot;).get();

        Element firstElement = document.getElementsByClass(&quot;portfolio-items&quot;).first();
        Elements ssElements = firstElement.getElementsByClass(&quot;hover-text&quot;);
        for (Element element : ssElements) {
            SSBean ssBean = new SSBean();
            String address = element.getElementsByTag(&quot;h4&quot;).first().getElementsByTag(&quot;span&quot;).text();
            String password = element.getElementsByTag(&quot;h4&quot;).get(2).getElementsByTag(&quot;span&quot;).first().text();
            String portString = element.getElementsByTag(&quot;h4&quot;).get(1).text();
            String port = portString.split(&quot;：&quot;)[1];
            String methodString = element.getElementsByTag(&quot;h4&quot;).get(3).text();
            String method = methodString.split(&quot;:&quot;)[1];
            ssBean.setAddress(address);
            ssBean.setPort(port);
            ssBean.setPassword(password);
            ssBean.setMethod(method);
            if (ssBean.getPassword() == null || ssBean.getPassword().isEmpty()) {
                continue;
            }
            ssBeanList.add(ssBean);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    return ssBeanList;
}
</code></pre><p>运行程序，我们便得到了这个List的账号数据<br><img src="http://ww3.sinaimg.cn/large/006HJ39wgy1fhqebcahidj30xs02wjrb.jpg" alt=""><br>是的，我们通过很简单的代码便获取到了这些账号数据，但是这些数据我们该怎么用呢？直接生成文件保存本地？每次使用都需要从网站去爬去这些数据？这些数据如何配置到SS？</p>
<p>停，停……</p>
<p>我已经不敢往下继续想了。</p>
<p><center><br><img src="http://ww1.sinaimg.cn/large/006HJ39wgy1fhqefs5eq4j308c08c74f.jpg" alt=""><br></center></p>
<h4 id="2-啊，我的思路呢"><a href="#2-啊，我的思路呢" class="headerlink" title="2.啊，我的思路呢"></a>2.啊，我的思路呢</h4><p>别闹，问题还是需要解决的。刚才我们使用很简单的代码获取到了网站上的账号数据，但是……</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhqekyq3i5j30so08ok52.jpg" alt=""></p>
<p>需要我给翻译吗？</p>
<p><img src="http://ww1.sinaimg.cn/large/006HJ39wgy1fhqekzha9kj30qp07t15o.jpg" alt=""></p>
<p>相信我，这不是网站自带的功能，真的是我翻译的，才怪。。。</p>
<p>也就是说，网站上的数据每6个小时更新一次，我们一次性抓取保存时没有用的，因为你下次用的时候他说不定已经过期了，你肯定回想那我就不存了啊，我有空了就去启动我的软件，或者我就在上面的时间段后去运行这段代码，好吧你真的不懒，是很闲啊。</p>
<ul>
<li>第一，我们的爬取代码肯定不能放在客户端，网站页面有访问限制，多次访问会被封ip（又是防抓取套路……）</li>
</ul>
<ul>
<li>第二，抓取代码需要定期执行，去自动抓取</li>
</ul>
<ul>
<li>第三，程序放在服务端将爬取的数据放在数据库，需要提供接口支持</li>
</ul>
<p>在上面提到我们没有使用python，因为python定时调度不好管理，而且接口部署没有java的spring boot这么简单。</p>
<p>下面就讲讲服务端的实现。</p>
<h4 id="3-呀，服务端"><a href="#3-呀，服务端" class="headerlink" title="3.呀，服务端"></a>3.呀，服务端</h4><p>既然服务端只是简单的接口实现和数据库存取操作，那么Spring boot肯定是首选啊，Spring boot在做微服务方面还是很方便的。</p>
<p><strong>页面爬去入库</strong></p>
<p>在model层实现对页面的爬去，在Controller层调用爬去方法定期执行，并提数据库查询接口。</p>
<pre><code>@Component
public class ScheduledTasks {
@Autowired
private SSRespository ssRespository;
private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class);

private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
SSAccountModel ssAccountModel;

@Scheduled(cron = &quot;0 0/15 0,6,12,18 * * *&quot; )
public void reportCurrentTime() {
    log.info(&quot;The time is now {}&quot;, dateFormat.format(new Date()));
    ssAccountModel = new SSAccountModelImpl();
    List&lt;SSBean&gt; ssAccount = ssAccountModel.getSSAccount();
    if (ssAccount == null || ssAccount.size() == 0) {
        log.info(&quot;爬取得信息：{}&quot;, &quot;爬取失败&quot;);
    } else {
        log.info(&quot;爬取得信息：{}&quot;, ssAccount.toString());
        ssRespository.deleteAll();
        ssRespository.save(ssAccount);
    }


}


}
</code></pre><p>使用@Scheduled(cron = “0 0/15 0,6,12,18 <em> </em> *” )注解实现程序在每天的0:15,6:15,12:15,18:15定期执行。</p>
<pre><code>ssRespository.deleteAll();
ssRespository.save(ssAccount);
</code></pre><p>如上代码，在插入数据库前清空数据库并插入，这样就实现了定期对网站页面的爬去和入库操作</p>
<p><strong>接口映射</strong></p>
<p>有了数据给客户端提供接口就显得很简单了，直接从数据库查询数据返回给调用者即可，当然这里没有对调用者做限制，主要演示实现。</p>
<pre><code>@RestController
public class SSCountController {
@Autowired
private SSRespository ssRespository;
@RequestMapping(&quot;/getAccount&quot;)
public Iterable&lt;SSBean&gt; getSSAccount() {
    Iterable&lt;SSBean&gt; all = ssRespository.findAll();
    return all;
    }
}
</code></pre><p>运行程序，在浏览器访问 <a href="http://localhost:8080/getAccount" target="_blank" rel="external">http://localhost:8080/getAccount</a> 即可。</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhqflljgyhj30s807174p.jpg" alt=""></p>
<p><a href="https://github.com/flyou/FreeSSApi" target="_blank" rel="external">点我下载源码</a></p>
<h4 id="4-嗨，客户端"><a href="#4-嗨，客户端" class="headerlink" title="4.嗨，客户端"></a>4.嗨，客户端</h4><p>由于考虑到在客户端（window）运行，考虑到没有安装jdk环境的，所以不能使用java打jar包实现，由于客户端的业务很简单，主要就是调用接口生成配置文件，打开SS客户端完成配置文件的加载。</p>
<p>考虑到生成exe文件，这里客户端就直接使用python来实现了</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
# --------------------------
# Author fzl
# Date 2017/7/20 15:13
# EMAIL fangjalylong@qq.com
# Desc 
# --------------------------
import json
import requests
import sys

from ExeUtil import ExeUtil

type = sys.getfilesystemencoding()

print( &quot;***************************************************************&quot;)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*******************欢迎使用免费代理更新程序********************&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*******************正在更新配置文件，请稍后********************&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;***************************************************************&quot;)

url = &apos;your url&apos;
data = requests.get(url)
beans=json.loads(data.text)
file=open(&quot;gui-config.json&quot;,&quot;w+&quot;)
file.write(&apos;&apos;&apos;{
  &quot;configs&quot;: [&apos;&apos;&apos;+&apos;\n&apos;)
for index in range(len(beans)):
file.writelines(&apos;{&apos;)
file.write(&apos;&apos;&apos;&quot;server&quot;: &quot;&apos;&apos;&apos;+beans[index][&apos;address&apos;].strip()+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;,\n&apos;)
file.write(&apos;&apos;&apos;&quot;server_port&quot;: &quot;&apos;&apos;&apos;+beans[index][&apos;port&apos;].strip()+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;,\n&apos;)
file.write(&apos;&apos;&apos;&quot;password&quot;: &quot;&apos;&apos;&apos;+beans[index][&apos;password&apos;].strip()+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;,\n&apos;)
file.write(&apos;&apos;&apos;&quot;method&quot;: &quot;&apos;&apos;&apos;+beans[index][&apos;method&apos;].strip()+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;,\n&apos;)
file.write(&apos;&apos;&apos;&quot;remarks&quot;: &quot;&apos;&apos;&apos;+beans[index][&apos;address&apos;].strip()+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;,\n&apos;)
file.write(&apos;&apos;&apos;&quot;timeout&quot;: &quot;&apos;&apos;&apos;+&apos;5&apos;+&apos;&apos;&apos;&quot;&apos;&apos;&apos;+&apos;\n&apos;)
if index==len(beans)-1:
    file.writelines(&apos;}&apos;)
else:
    file.writelines(&apos;},&apos;)

file.write(&apos;&apos;&apos; ],
  &quot;strategy&quot;: null,
  &quot;index&quot;: 0,
  &quot;global&quot;: true,
  &quot;enabled&quot;: false,
  &quot;shareOverLan&quot;: true,
  &quot;isDefault&quot;: false,
  &quot;localPort&quot;: 1080,
  &quot;pacUrl&quot;: null,
  &quot;useOnlinePac&quot;: false,
  &quot;secureLocalPac&quot;: true,
  &quot;availabilityStatistics&quot;: false,
  &quot;autoCheckUpdate&quot;: true,
  &quot;checkPreRelease&quot;: false,
  &quot;isVerboseLogging&quot;: true,
  &quot;logViewer&quot;: {
&quot;topMost&quot;: false,
&quot;wrapText&quot;: true,
&quot;toolbarShown&quot;: false,
&quot;Font&quot;: &quot;Consolas, 8pt&quot;,
&quot;BackgroundColor&quot;: &quot;Black&quot;,
&quot;TextColor&quot;: &quot;White&quot;
  },
  &quot;proxy&quot;: {
    &quot;useProxy&quot;: false,
       &quot;proxyType&quot;: 0,
    &quot;proxyServer&quot;: &quot;&quot;,
    &quot;proxyPort&quot;: 0,
    &quot;proxyTimeout&quot;: 3
  },
  &quot;hotkey&quot;: {
&quot;SwitchSystemProxy&quot;: &quot;&quot;,
&quot;SwitchSystemProxyMode&quot;: &quot;&quot;,
&quot;SwitchAllowLan&quot;: &quot;&quot;,
&quot;ShowLogs&quot;: &quot;&quot;,
&quot;ServerMoveUp&quot;: &quot;&quot;,
&quot;ServerMoveDown&quot;: &quot;&quot;
  }
}&apos;&apos;&apos;)
file.close()
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*    SS默认选中第一个代理账号，如不可用请尝试切换其他账号     *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*             配置文件已经更新,Shadowsocks已经启动            *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                               by：flyou     *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                    http://www.flyou.ren     *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;*                                                             *&quot;).decode(&apos;utf-8&apos;).encode(type)
print( &quot;***************************************************************&quot;)
exeUtil=ExeUtil(&apos;.&apos;,&apos;Shadowsocks.exe&apos;)
exeUtil.openExe()
</code></pre><p>打开exe工具类</p>
<pre><code>class ExeUtil:
def __init__(self, filePath, fileName):
    self.filePath = filePath
    self.fileName = fileName

def openExe(self):
    try :
        handle = win32process.CreateProcess(os.path.join(self.filePath, self.fileName),
            &apos;&apos;, None, None, 0,
            win32process.CREATE_NO_WINDOW,
            None ,
            self.filePath,
            win32process.STARTUPINFO())
        running = True
    except Exception, e:

        print &quot;Create Error!&quot;
        handle = None
        running = False

    while running :
     rc = win32event.WaitForSingleObject(handle[0], 1000)
     if rc == win32event.WAIT_OBJECT_0:
            running = False
#end while
            print &quot;GoodBye&quot;
</code></pre><p><strong><a href="https://github.com/flyou/FreeSSClient" target="_blank" rel="external">点我下载源码</a></strong></p>
<h4 id="5-哈-，试一试效果"><a href="#5-哈-，试一试效果" class="headerlink" title="5.哈 ，试一试效果"></a>5.哈 ，试一试效果</h4><p>执行代码，即可完成配置文件的生成和装载</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhqg9otgmyj30fh0a50sv.jpg" alt=""></p>
<p>此时，Shadowsocks应用就会已经启动（目录下需要有Shadowsocks）并成功加载相应的账号配置，如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006HJ39wgy1fhqg9ouwxgj30cx0a3jrj.jpg" alt=""></p>
<p>浏览器如何配置代理请参照上一篇文章</p>
<p><a href="http://flyou.ren/2017/06/15/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B8%A4%E4%B8%89%E4%BA%8B/">关于科学上网两三事</a></p>
<p>注意，抓取的账号不是每一个都可以用，但是至少有3、4个是很快的，右键点击ss尝试切换不同的账号吧。<br><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fhqgj0zohij30dd0f30w7.jpg" alt=""></p>
<p><strong>NOW，DO WHAT YOU WANT TO DO</strong><br><img src="http://ww3.sinaimg.cn/large/006HJ39wgy1fhqgqctva6j30ph0bs0sx.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/006HJ39wgy1fhqgffzd9uj311b0kkkee.jpg" alt=""></p>
<h2 id="最后还要唠叨几句"><a href="#最后还要唠叨几句" class="headerlink" title="最后还要唠叨几句"></a>最后还要唠叨几句</h2><p>说了这么多，你的安装文件呢？哎呀，只顾着学习（装逼）忘记留种了%^……^%</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhqgtkpzafj30ci099t8x.jpg" alt=""></p>
<p><a href="https://pan.baidu.com/s/1jHAYmHo" target="_blank" rel="external">点我下载-百度云</a></p>
<p>密码: 7rbj</p>
<p><strong><em>关于软件的使用说明</em></strong>：</p>
<blockquote>
<p>1.解压FreeShadowsocks.rar到任意目录</p>
<p>2.点击FreeShadowsocks.exe邮件发送到桌面快捷方式</p>
<p>3.点击桌面快捷方式即可打开程序。</p>
<p>备注：</p>
<p>本软件只是定时获取网络上可用的SS账号数据并下发配置文件到本地</p>
<p>如果发现账号不可用请切换到其他代理账号重试或者退出SS重新打开本软件</p>
<p>原则上账号数据会每6个小时更新一次</p>
<p>服务器会在每天的0:15,6:15，12:15和18:15去重新生成相应账号</p>
<p>请务必在此时段重新打开本软件已获取最新的账号数据，以保证正常使用代理</p>
</blockquote>
<p>更新，连接超时时间5-&gt;15，用户可以在ss的设置界面来设置不同账号的超时时间。</p>
<p><strong><em>最后本软件最终解释权归作者所有，转载请注明出处</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于科学上网两三事]]></title>
      <url>http://flyou.ren/2017/06/15/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B8%A4%E4%B8%89%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直以来，我都觉得自由的网络是不应该有限制的。作者也是饱受其扰，也在翻土啬的道路上走了很久。从最开始的修改HOST文件，到使用免费代理软件，到购买vpn服务，再到现在的自己搭梯子。<br></p>
<p>期间有很多无奈，有频繁修改HOST的烦躁，有第三方软件不稳地的惆怅，更有服务商跑路的愤慨。</p>
<p>今天写下这篇文章，主要是让大家了解土啬和梯子，在出土啬的路上少走弯路。</p>
<h2 id="为什么是科学上网"><a href="#为什么是科学上网" class="headerlink" title="为什么是科学上网"></a>为什么是科学上网</h2><p>在很久很久以前，我依稀可以记得那时候访问google和Facebook是很流畅的，是因为那时候网络连接的方式是直接连接的</p>
<p><img src="http://ww2.sinaimg.cn/large/a15b4afegy1fhmzlrunjbj20gf03et8k.jpg" alt=""></p>
<p><em>但是为了更好的管理国人的访问页面和一些其他的政治因素，GWF就慢慢出现在了我们直接连接其他网站的中间。</em></p>
<blockquote>
<p>在90年代初期，中国大陆只有教育网、高能所和公用数据网3个国家级网关出口，中国政府对认为具有颠覆性质的站点进行IP封锁，这是有效的封锁手段。随着时间的推移对于IP封锁，用普通Proxy技术就可以绕过。</p>
<p>在2002年左右，中国大陆研发了一套系统，并规定各个因特网服务提供商必须使用。思科等公司的高级路由设备帮助中国大陆实现了关键字过滤。</p>
<p>从2007年2月前后，GFW开始对境外及境内的Wap网站含有的敏感字符进行过滤。</p>
<p>从2012年12月开始，有报道称中国加强了其互联网防火墙，其主要目的在于阻止用户访问政治敏感信息。</p>
</blockquote>
<p><em>GFW: 防火长城，也称中国防火墙或中国国家防火墙，指中华人民共和国政府在其管辖互联网内部建立的多套网络审查系统的总称，包括相关行政审查系统。其英文名称Great Firewall of China（与长城 Great Wall 相谐的效果），简写为Great Firewall，缩写GFW</em></p>
<h2 id="为什么要进行科学上网"><a href="#为什么要进行科学上网" class="headerlink" title="为什么要进行科学上网"></a>为什么要进行科学上网</h2><p>下面是根据调查显示的一组数据<br><img src="http://ww2.sinaimg.cn/large/a15b4afegy1fhmz2ttjhoj20hi0cnjry.jpg" alt=""></p>
<p>咦，倒数第三个是什么？<br><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn0w4t1wdj20dw0dwmxj.jpg" alt=""><br>还好我只是真的只用前三个……</p>
<h2 id="科学上网的几种方式"><a href="#科学上网的几种方式" class="headerlink" title="科学上网的几种方式"></a>科学上网的几种方式</h2><h3 id="1-修改本地host文件（不推荐）"><a href="#1-修改本地host文件（不推荐）" class="headerlink" title="1.修改本地host文件（不推荐）"></a>1.修改本地host文件（不推荐）</h3><p>使用修改hosts文件的方式，其实是绕过DNS直接将域名转跳到相应ip的方式来完成代理的。<br>之所以GFW能拦截你的请求是因为，GFW 会对 DNS 的解析过程进行干扰，这会使对某些被干扰的域名返回一个错误的 IP 地址给你的主机，使你无法正确连接到你要的服务器上读取正确的信息。</p>
<p>而使用Hosts 文件本来是用来提高解析效率，在进行 DNS 请求以前，系统会先检查自己的 Hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。</p>
<p>也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。所以，当我们直接将 Google、Twitter、Facebook 之类的 IP 放入 Hosts 文件后，就可以跳过 DNS 的解析这一步，直接就行 IP 访问，不受 GFW 的 DNS 污染干扰了。</p>
<p>就是为什么 Hosts 的 IP 要时不时更改，为什么 FB、Twitter 会仍旧上不去。是因为 GFW 的第二个大招，IP 封锁。</p>
<p>比如访问国外一个 IP 无法访问，Ping 不通，tracert 这个 IP 后发现，全部在边缘路由器 (GFW) 附近被拦截。换言之，GFW 直接拦截带有这个 IP 头的数据包。</p>
<p>所以，如果你更改的 IP 被封锁了，就算你过了 DNS 这一关，也仍旧不能翻过 GFW。</p>
<h3 id="2-使用第三方代理软件"><a href="#2-使用第三方代理软件" class="headerlink" title="2.使用第三方代理软件"></a>2.使用第三方代理软件</h3><p><a href="https://github.com/getlantern/lantern" target="_blank" rel="external">蓝灯lantern：</a></p>
<p>lantern的原理其实很简单，类似于曾经很流行的p2p下载模式<br><br>当浏览者浏览的网站并没有被墙的时候，lantern并不会介入其中，你就是使用的自然流量进行浏览的，只有当lantern发现你访问的是一个被封锁的网站的时候，它才会介入其中.也就是说，它内部实现了类似PAC的机制。</p>
<p><a href="https://github.com/XX-net/XX-Net" title="XX-Net" target="_blank" rel="external">XXNet</a></p>
<p>它是基于X_Tunnel的升级封装版<br><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn471pj1jj215o0ge0ut.jpg" alt=""><br>原理如上<br><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn5y35gflj20k303pmx4.jpg" alt=""></p>
<h3 id="3-vpn代理服务（不推荐）"><a href="#3-vpn代理服务（不推荐）" class="headerlink" title="3.vpn代理服务（不推荐）"></a>3.vpn代理服务（不推荐）</h3><p>虚拟私人网路（英语：Virtual Private Network，简称 VPN ），其常见协议包括 L2TP、PPTP、SSL、OpenVPN等。常用的软件有蓝灯（Lantern）、赛风、GreenVPN、VPN Master Pro 等。</p>
<p>其使用加密穿隧协议，通过阻止截听与嗅探来提供机密性，还允许发送者身份验证，以阻止身份伪造，同时通过防止信息被修改提供消息完整性。但很多虚拟私人网络不使用加密保护数据。例如，一条通过GRE协议在两台主机间建立的隧道属于虚拟私人网络，但既不安全也不可信。除以上的GRE协议例子外，原生的明文穿隧协议包括L2TP和PPTP。</p>
<p>因此在用户使用该方法上网时，数据上传到私人网络极易被窃取用户数据、密码等。</p>
<p>由于今年相关规定实行后，对于该方法审查力度更加严格，多数免费版将无法使用，其网速也不能良好体验视频等服务，另一方面由于其协议的原因，安全性也是一大问题，无论是免费还是付费都极易被窃取数据，并且由于 ip 不定的原因，登陆各平台经常会出现异地异常的情况。</p>
<p><em>（2017年1月22日，中华人民共和国工业和信息化部发布《工业和信息化部关于清理规范互联网网络接入服务市场的通知》，规定未经电信主管部门（各一级行政区通信管理局）批准，不得自行建立或租用VPN等其他信道开展跨境经营活动。这也意味着中国大陆民众如需要建立VPN翻墙上网，必须取得各一级行政区通信管理局的批准。）</em></p>
<p>现在市面上大多数的第三方平台都是出售的vpn账号，但是由于服务器、GFW频繁封锁等原因，第三方的服务一般也是不稳地，时而很慢，时而有点慢。<br>下面是如何在自己服务器搭建vpn服务的教程。</p>
<p><strong>备注</strong>：VPN可以应该用于所有的协议，适用于所有的场景，对于稳定的VPN来说玩游戏是最佳的选择。</p>
<p><a href="http://blog.csdn.net/hongyingaaa/article/details/51761386" target="_blank" rel="external">如何自己搭建VPN服务器</a></p>
<h3 id="4-Shadowsocks"><a href="#4-Shadowsocks" class="headerlink" title="4.Shadowsocks"></a>4.Shadowsocks</h3><p>hadowsocks（中文名称：影梭），简称Ss。使用 Python、C#等语言开发、基于 Apache 许可证的开放原始码软件，用于保护网络流量、加密资料传输。Shadowsocks 使用 Socks5 代理方式。</p>
<p>Shadowsocks 分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并建立本地代理。</p>
<p>其优点是使用自行设计的协议进行加密，常见的加密算法如AES、RC4等，每次数据请求只转发一个连接，因此网速很快，可达到与实际网速相同的传输速度，在移动设备上也更省电方便。</p>
<p>正是由于其特殊的算法加密，其安全性是相比而言最高的，因此可以享受更高品质的上网体验。</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn5y3kf8rj20j808xq2z.jpg" alt=""></p>
<p><strong>下面主要介绍下，Shadowsocks的配置方式。</strong></p>
<h4 id="1、以-Vultr-为例，注册帐户并登录Vultr"><a href="#1、以-Vultr-为例，注册帐户并登录Vultr" class="headerlink" title="1、以 Vultr 为例，注册帐户并登录Vultr"></a>1、以 Vultr 为例，注册帐户并登录<a href="http://www.vultr.com/?ref=7126907" target="_blank" rel="external">Vultr</a></h4><h4 id="第一步：点击创建按钮"><a href="#第一步：点击创建按钮" class="headerlink" title="第一步：点击创建按钮"></a>第一步：点击创建按钮</h4><p><img src="http://wx2.sinaimg.cn/mw690/a2f7c645ly1fhn4vusjbvj211y0asgmi.jpg" alt=""></p>
<h4 id="第二步：选择数据中心"><a href="#第二步：选择数据中心" class="headerlink" title="第二步：选择数据中心"></a>第二步：选择数据中心</h4><p><img src="http://wx4.sinaimg.cn/mw690/a2f7c645ly1fhn4vv7xl8j211y0dwmyd.jpg" alt=""></p>
<h4 id="第三步：选择操作系统"><a href="#第三步：选择操作系统" class="headerlink" title="第三步：选择操作系统"></a>第三步：选择操作系统</h4><p><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn4vvn5g9j211y0dwwfo.jpg" alt=""></p>
<h4 id="第四步：选择套餐规格，推荐第一个就够了（500G流量-月-2-5-）"><a href="#第四步：选择套餐规格，推荐第一个就够了（500G流量-月-2-5-）" class="headerlink" title="第四步：选择套餐规格，推荐第一个就够了（500G流量/月/2.5$）"></a>第四步：选择套餐规格，推荐第一个就够了（500G流量/月/2.5$）</h4><p><img src="http://wx2.sinaimg.cn/mw690/a2f7c645ly1fhn4vwas14j211y0c8wg5.jpg" alt=""></p>
<h4 id="第五步：设置系统名字"><a href="#第五步：设置系统名字" class="headerlink" title="第五步：设置系统名字"></a>第五步：设置系统名字</h4><p><img src="http://wx4.sinaimg.cn/mw690/a2f7c645ly1fhn4vx07s7j211y0egmy8.jpg" alt=""></p>
<h4 id="第六步：等待安装完成"><a href="#第六步：等待安装完成" class="headerlink" title="第六步：等待安装完成"></a>第六步：等待安装完成</h4><p><img src="http://wx4.sinaimg.cn/mw690/a2f7c645ly1fhn4vy9hpyj211y0egdh9.jpg" alt=""></p>
<h4 id="第七步：打开管理菜单，查看登陆名密码"><a href="#第七步：打开管理菜单，查看登陆名密码" class="headerlink" title="第七步：打开管理菜单，查看登陆名密码"></a>第七步：打开管理菜单，查看登陆名密码</h4><p><img src="http://wx1.sinaimg.cn/mw690/a2f7c645ly1fhn4vyqparj211y0fu766.jpg" alt=""></p>
<h4 id="第八步：登录进入系统"><a href="#第八步：登录进入系统" class="headerlink" title="第八步：登录进入系统"></a>第八步：登录进入系统</h4><p><img src="http://wx2.sinaimg.cn/mw690/a2f7c645ly1fhn4vz8d1rj211x0i2jsi.jpg" alt=""></p>
<h4 id="第九步：安装服务端"><a href="#第九步：安装服务端" class="headerlink" title="第九步：安装服务端"></a>第九步：安装服务端</h4><p><strong>以下Linux服务器操作命令，如有不了解，请自行百度</strong></p>
<pre><code>$ yum install m2crypto python-setuptools
$ easy_install pip
$ pip install shadowsocks
</code></pre><h4 id="第十步：配置服务器参数"><a href="#第十步：配置服务器参数" class="headerlink" title="第十步：配置服务器参数"></a>第十步：配置服务器参数</h4><pre><code>$ vi  /etc/shadowsocks.json
</code></pre><p>写入如下配置：</p>
<pre><code>{
&quot;server&quot;:&quot;0.0.0.0&quot;,
&quot;server_port&quot;:443,
&quot;local_address&quot;: &quot;127.0.0.1&quot;,
&quot;local_port&quot;:8388,
&quot;password&quot;:&quot;123456&quot;,
&quot;timeout&quot;:300,
&quot;method&quot;:&quot;aes-256-cfb&quot;,
&quot;fast_open&quot;: false
}
</code></pre><p>加密方式官方默认使用aes-256-cfb</p>
<p>server: 服务器IP</p>
<p>server_port: 服务器防火墙开放端口</p>
<p>local_port: 客户端本地端端口</p>
<p>password: 用来加密的密码</p>
<p>timeout:超时时间（秒）</p>
<p>method:加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″等</p>
<p>原则上shadowsocks是支持多用户同时在线的，但是如果你为了区分访问信息，也可以设置多端口即可</p>
<pre><code>{
&quot;server&quot;:&quot;0.0.0.0&quot;,
&quot;local_address&quot;: &quot;127.0.0.1&quot;,
&quot;local_port&quot;:8388,
&quot;port_password&quot;: {
     &quot;443&quot;: &quot;443&quot;,
     &quot;8888&quot;: &quot;8888&quot;
 },
&quot;timeout&quot;:300,
&quot;method&quot;:&quot;aes-256-cfb&quot;,
&quot;fast_open&quot;: false
}
</code></pre><p>然后保存退出。</p>
<h4 id="第十一步：配置防火墙"><a href="#第十一步：配置防火墙" class="headerlink" title="第十一步：配置防火墙"></a>第十一步：配置防火墙</h4><p>开启端口，重启firewalld 服务，下面的ss是上述的文件的名字，区分大小写</p>
<pre><code>$ firewall-cmd --permanent --add-service=ss
$ firewall-cmd --reload
</code></pre><p>启动 Shadowsocks 服务</p>
<pre><code>$ ssserver -c /etc/shadowsocks.json
</code></pre><p>如果想干点其他的实现后台运行，使用</p>
<pre><code>$ nohup ssserver -c /etc/shadowsocks.json &amp;
</code></pre><h4 id="第十二步：客户端连接"><a href="#第十二步：客户端连接" class="headerlink" title="第十二步：客户端连接"></a>第十二步：客户端连接</h4><p>window用户直接下载Shadowsocks，运行软件如下<br><img src="http://c13.eoemarket.net/app0/199/199651/icon/725846_480.png" alt=""><br><img src="http://wx2.sinaimg.cn/mw690/a2f7c645ly1fhn5cdn2lkj20cx0a3jro.jpg" alt=""></p>
<p>按照配置文件里的配置进行配置即可，配置完成后右键启用系统代理即可完成科学上网。<br><img src="http://wx2.sinaimg.cn/mw690/a2f7c645ly1fhn5e5pj12j205u06vdft.jpg" alt=""></p>
<p>但是，如果你想要浏览区走ss可以直接安装浏览器插件</p>
<p>switchysharp或者switchyomega等类似软件代理本地即可，<br><img src="http://wx2.sinaimg.cn/mw690/a2f7c645gy1fhn5hu08u1j20j9083glv.jpg" alt=""></p>
<p><img src="http://wx3.sinaimg.cn/mw690/a2f7c645gy1fhn5jdwpmtj204e05bmx5.jpg" alt=""><br>即可完成自由上网。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a2f7c645gy1fhn5lqcerxj213l0li49k.jpg" alt=""></p>
<p>Android客户端，mac客户端配置基本同上，</p>
<p>IOS用户可以使用Surge for iOS ，Shadowrocket for Shadowsocks<br>完成相同的网络代理体验。</p>
<p>备注：</p>
<p>1、由于ss的流量走的是http代理，所以部分游戏没有办法使用，使用<a href="http://www.proxifier.com/" target="_blank" rel="external">proxifier</a>可以完成你对某些应用的<br>全部代理。</p>
<p>2、如果，配置完成客户端无法连接服务器，请检查服务端配置和服务器防火墙对Shadowsocks的端口是否开启。</p>
<p>文章最后分下个免费SS账号的网站吧，可以做临时使用，不保证稳定性哦。</p>
<p><a href="http://ss.ishadowx.com/" title="点我免费账号" target="_blank" rel="external">点我免费账号</a></p>
<p><strong>现在去干想做的事去吧。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于RxJava背压]]></title>
      <url>http://flyou.ren/2017/04/05/%E5%85%B3%E4%BA%8ERxJava%E8%83%8C%E5%8E%8B/</url>
      <content type="html"><![CDATA[<h2 id="关于RxJava背压"><a href="#关于RxJava背压" class="headerlink" title="关于RxJava背压"></a>关于RxJava背压</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>适用人群：</p>
<p>了解RXJava1.0、RxJava2.0基本用法，了解RxJava的一些常用操作符的小伙伴</p>
<p><strong>讲些什么：</strong></p>
<ol>
<li>了解背压是什么？</li>
<li>了解阻塞形成的原因</li>
<li>怎么去解决阻塞</li>
<li>RxJava对背压的处理</li>
</ol>
<p><strong>为什么讲：</strong></p>
<p>学习RxJava2.0用法，熟悉背压机制（我差点信了自己）</p>
<p><strong>能讲好吗：</strong></p>
<p>被闹，又不是开车，这我哪知道啊！<br><br></p>
<p><em>好吧不扯了，开车吧，不不，是开始学习下背压</em><br><br><br><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fecw2xtjdxj309t064aa1.jpg" alt=""><br><br><br><br></p>
<h3 id="什么是背压"><a href="#什么是背压" class="headerlink" title="什么是背压"></a>什么是背压</h3><p>在RXJava2.0出来以后，就有很多人提’背压’这个东西，看了很多篇文章（其实都是一篇）依旧在云上下不来，到底什么是’背压’呢？</p>
<p>Google上搜索结果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1febtjc1zzlj30ia04p0so.jpg" alt=""></p>
<p>我的第一反应完全是懵逼的，你在说啥？到底想说啥？</p>
<p>其实仔细想想在RxJava中大概是这个意思，</p>
<blockquote>
<p>被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息，从而操作消息的阻塞现象。</p>
</blockquote>
<p>或者这样理解：</p>
<blockquote>
<p>水坝在储水的过程中同样也向下游放水来保持坝内的水位，但是如果发大洪水，上游水量很大，而大坝处理能力有限，坝内的水位必定会上升甚至最终漫过大坝。</p>
</blockquote>
<p>在RxJava中，阻塞不一定会出现异常，但是肯定会多少对系统的性能和功能造成一定的影响。</p>
<hr>

<h3 id="阻塞是怎么形成的？"><a href="#阻塞是怎么形成的？" class="headerlink" title="阻塞是怎么形成的？"></a>阻塞是怎么形成的？</h3><p>正如上面所说的当下游不能快速处理上游发来的事件事件时，而造成的事件阻塞现象。</p>
<h4 id="RxJava1-0"><a href="#RxJava1-0" class="headerlink" title="RxJava1.0"></a>RxJava1.0</h4><p>在<strong>RxJava1.0</strong>中，Observable是支持背压的，翻下源码，可以看到在Rxjava1.0中的Buffer的大小为16</p>
<p><strong>Observable.java 3551行</strong></p>
<pre><code> public final &lt;B&gt; Observable&lt;List&lt;T&gt;&gt; buffer(Observable&lt;B&gt; boundary) {
    return buffer(boundary, 16);
}
</code></pre><p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fecwg02xrhj308c08cdfx.jpg" alt=""></p>
<pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
      @Override
      public void call(Subscriber&lt;? super Integer&gt; subscriber) {
          for (int i = 0;; i++) {   //无限循环发事件
              subscriber.onNext(i);
          }
      }
  }).subscribe(new Action1&lt;Integer&gt;() {
              @Override
              public void call(Integer integer) {
                  Log.d(TAG, &quot;&quot; + integer);
              }
          });
</code></pre><p>效果如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1febvgxq6wlg30g107ye81.gif" alt=""></p>
<p>由于缓存池buffer的大小为16，照理说程序运行肯定会抛出个我们熟悉的异常<br><strong>MissingBackpressureException</strong>啊，但是结果却是令我们万分诧异，我的内存啊……。</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1febtmay5u8j308c08c744.jpg" alt=""></p>
<p><em>其实，原因很简单，由于RxJava观察者线程和被观察者处于同一线程，在同一个线程中，被观察需要等待观察者将事件处理完毕后才会继续发送下面的事件，所以上面才会出现这样的情况。</em></p>
<p>那么，我们让他们处于不同的线程再试下</p>
<pre><code>   Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {   //无限循环发事件
            emitter.onNext(i);
        }
    }
}).subscribeOn(Schedulers.io())
  .observeOn(AndroidSchedulers.mainThread())
  .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                Log.d(TAG, &quot;&quot; + integer);
            }
        });
</code></pre><p>你要的MissingBackpressureException拿去不谢。</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1febvrmp8xbj30lj022dfv.jpg" alt=""></p>
<p>什么？你不信Rxjava1.0中的Buffer大小是16？你不信算了……<br>开玩笑，我是一个不以理服人的人吗？很显然，是的！</p>
<p>继续吃上面的大栗子：</p>
<pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
       @Override
       public void call(Subscriber&lt;? super Integer&gt; subscriber) {
           for (int i = 0;i&lt;16; i++) {   //短时间，发送16个事件
               subscriber.onNext(i);
           }
       }
   }).subscribeOn(Schedulers.io())
           .observeOn(AndroidSchedulers.mainThread())
           .subscribe(new Action1&lt;Integer&gt;() {
               @Override
               public void call(Integer integer) {
                   Log.d(TAG, &quot;&quot; + integer);
               }
           });
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1febw0neukvj30ga09qgn1.jpg" alt=""></p>
<p><em>看看这是啥？这不就是下游对上游事件的相应吗?请注意，这次我们仅仅发送了16个事件，下游就能正常处理事件了，但是如果我们把循环值改成17，我们再来看看。</em></p>
<pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
      @Override
      public void call(Subscriber&lt;? super Integer&gt; subscriber) {
          for (int i = 0;i&lt;17; i++) {//短时间，发送17个事件
              subscriber.onNext(i);
          }
      }
  }).subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())
          .subscribe(new Action1&lt;Integer&gt;() {
              @Override
              public void call(Integer integer) {
                  Log.d(TAG, &quot;&quot; + integer);
              }
          });
</code></pre><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1febw4xxufkj30k703et8z.jpg" alt=""></p>
<p>没错，没给你闹着玩，他真的又抛出大家喜欢的异常了，没毛病。</p>
<p>不知道，大家看完了RxJava1.0的背压，对它有什么看法？下面是我对RxJava1.0背压的一些理解</p>
<ol>
<li>首先，RxJava1.0的背压事件缓存池很小，只有16，不能够处理较大量的并发事件。</li>
<li>Rxjava1.0 中上游（被观察者）无法得知下游（观察者）对事件的处理能力和事件处理进度，只能把事件一股脑的抛给下游。</li>
<li>Rxjava1.0有很多事件不被能正确的背压，从而抛出MissingBackpressureException</li>
</ol>
<hr>

<h4 id="RxJava2-0"><a href="#RxJava2-0" class="headerlink" title="RxJava2.0"></a>RxJava2.0</h4><p>RXJava2.0中Observable不再支持背压，多出了Flowable来支持背压操作</p>
<p>既然说Observable不再支持背压，那么我们随便搞应该就不会报哪个MissingBackpressureException了吧？</p>
<pre><code>  Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {   //无限循环发事件
            emitter.onNext(i);
        }
    }
}).subscribeOn(Schedulers.io())
  .observeOn(AndroidSchedulers.mainThread())
  .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                Log.d(TAG, &quot;&quot; + integer);
            }
        });
</code></pre><p>上面的例子中我们创建了一个Observable（被观察者/上游）来发送无限循环的事件，观察者（下游）让下游来处理事件。</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1febuo82kfwg30bh06h43w.gif" alt=""></p>
<p>虽然说，不报异常了但是这内存也是看的我眼疼，崩溃也是正常现象啊，这么看来背压操作还是很有必要的啊，不然程序分分钟崩溃一次，怪我咯^&amp;</p>
<h3 id="如何解决阻塞"><a href="#如何解决阻塞" class="headerlink" title="如何解决阻塞"></a>如何解决阻塞</h3><p><em>当然，提到如何解决阻塞问题吗，大家肯定会首先想到“背压”啊，好吧背压策略确实很神奇，但是它也不是万能的啊，你不了解也不能乱用啊，它也是哥，不要太迷信它</em></p>
<p>在上面的例子里，就上一个，不是其他的！在上面的例子里我们再RxJava2.0中是使用Observable一直发送死循环事件，由于下游没有任何<strong>背压策略</strong>，所以上游的每个事件，下游都要一一进行处理，所以程序的内存就一直开车，最后翻车也再说难免。</p>
<blockquote>
<p>确实，是因为上游在短时间发送太多的事件，让下游来不及处理就造成了事件的阻塞，那么我们是否可以用一些自己的方法来解决这种阻塞呢？</p>
<p>使用背压啊！<br><br>“你妹的，说好的用自己的办法呢？”</p>
</blockquote>
<p>首先，我们分析阻塞形成的原因，无非是因为下面的原因啊：</p>
<ol>
<li>上游的水流过快（上游发送事件过快）</li>
<li>上游水流量过大（上游发送事件过多）</li>
</ol>
<p>总结来说就是短时间发送的事件过多，下游忙不过来！</p>
<p><strong>好吧，首先我们用第一种办法试下，让上游发送事件的速度慢点</strong></p>
<pre><code>   //控制发送速度，减少内存消耗

Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {   //无限循环发事件
            emitter.onNext(i);
            Thread.sleep(1000);
        }
    }
}).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                Log.d(TAG, &quot;&quot; + integer);
            }
        });
</code></pre><p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1febxaks9scg30a7071wgk.gif" alt=""></p>
<p>这样来看，我的内存就稳定，老铁稳。</p>
<p><strong>那么，试试第二种方法，下游少接收点事件</strong></p>
<pre><code>//定时取样
Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {   //无限循环发事件
            emitter.onNext(i);

        }
    }
}).sample(1, TimeUnit.SECONDS)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                Log.d(TAG, &quot;&quot; + integer);
            }
        });
</code></pre><p>或者是用过滤操作符，过滤掉一些上游事件</p>
<pre><code>    //过滤器 过滤操作
Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0; ; i++) {   //无限循环发事件
            emitter.onNext(i);

        }
    }
}).filter(new Predicate&lt;Integer&gt;() {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer % 100 == 0;

    }
})
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(Integer integer) throws Exception {

                Log.d(TAG, &quot;&quot; + integer);
            }
        });
</code></pre><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1febxkcasihg309t073aba.gif" alt=""><br><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1febxkk422gg309t073abb.gif" alt=""></p>
<hr>

<h2 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h2><p>上面唠唠叨叨说了那么多，基本上也给大家阐明了阻塞形成的原因和解决阻塞的方法，基本策略就是减少发送事件的频率和减少发送事件的数量。<br><br>But……<br><br><br>我们手动让上游发送事件的速度满下来貌似是不可取的，你想让上游的速度十多快呢？上游需要等多久呢？<br><br>还有……<br><br><br>我们依旧无法知道下游处理事件的能力，无法很好地处理阻塞的事件。<br><br>当然，你们肯定会说RxJava2.0不是很好地支了背压了吗？是的，确实比较好地对阻塞做了处理，咱们来看下吧。</p>
<p>在RxJava2.0中官方，推出了Flowable 和Subscriber用来支持背压，同样的去除了Observable对背压的支持，对的就像你上面看到的，Observable不再支持背压了，即使阻塞崩溃也不会抛出MissingBackpressureException</p>
<p>还是上代码看看，Flowable的用法吧。</p>
<pre><code>Flowable.create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode)
</code></pre><p>创建Flowable会默认让传入一个FlowableOnSubscribe和一个BackpressureStrategy，FlowableOnSubscribe很好理解就是一个就是Flowable的一个被观察者源，而BackpressureStrategy就是Flowable提供的背压策略</p>
<p>有哪些策略还是上源码看下吧：</p>
<pre><code>public enum BackpressureStrategy {
/**
 * OnNext events are written without any buffering or dropping.
 * Downstream has to deal with any overflow.
 * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.
 */
MISSING,
/**
 * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.
 */
ERROR,
/**
 * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.
 */
BUFFER,
/**
 * Drops the most recent onNext value if the downstream can&apos;t keep up.
 */
DROP,
/**
 * Keeps only the latest onNext value, overwriting any previous value if the
 * downstream can&apos;t keep up.
 */
LATEST
}
</code></pre><p><strong>MISSING：</strong><br>如果流的速度无法保持同步，可能会抛出MissingBackpressureException或IllegalStateException。</p>
<p><strong>BUFFER</strong><br>上游不断的发出onNext请求，直到下游处理完，也就是和Observable一样了，缓存池无限大，最后直到程序崩溃</p>
<p><strong>ERROR</strong><br>会在下游跟不上速度时抛出MissingBackpressureException。</p>
<p><strong>DROP</strong><br>会在下游跟不上速度时把onNext的值丢弃。</p>
<p><strong>LATEST</strong><br>会一直保留最新的onNext的值，直到被下游消费掉。</p>
<p><hr><br>先不看上面的策略，我们最起码先看看Flowable怎么用吧</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
     @Override
     public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
         Log.d(TAG, &quot;emit 1&quot;);
         emitter.onNext(1);
         Log.d(TAG, &quot;emit 2&quot;);
         emitter.onNext(2);
         Log.d(TAG, &quot;emit 3&quot;);
         emitter.onNext(3);
         Log.d(TAG, &quot;emit complete&quot;);
         emitter.onComplete();

     }
 }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
         .subscribe(new Subscriber&lt;Integer&gt;() {
             @Override
             public void onSubscribe(Subscription s) {

             }

             @Override
             public void onNext(Integer s) {
             Log.d(TAG, &quot;onNext: &quot; + integer);
             }

             @Override
             public void onError(Throwable t) {
             Log.d(TAG, &quot;onError&quot;+t);

             }

             @Override
             public void onComplete() {   
             Log.d(TAG, &quot;onComplete&quot;);

             }
         });
</code></pre><p>上游 Flowable 构建FlowableEmitter用来发送上游事件，这里的背压策略我们采用ERROR，下游方法中出现了一个和原来</p>
<pre><code>@Override
public void onSubscribe(Subscription s) {

               }
</code></pre><p><strong>Subscription.java</strong></p>
<pre><code>public interface Subscription {

public void request(long n);

public void cancel();

}
</code></pre><p>这里需要重点说明一下，在Flowable中背压采取拉取响应的方式来进行水流控制，也就是说Subscription是控制上下游水流的主要方式，一般的，我们需要调用Subscription.request（）来传入一个下游<strong>目前</strong>能处理的事件的数量</p>
<p>那么，我们不传会怎么样？</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fecr4rx0gbj30h702hjrl.jpg" alt=""></p>
<p><strong>备注：这里上下游是在不同的线程里进行的，如果在同一个线程里，它也会抛出一个MissingBackpressureException，让你去设置 调用request（）方法</strong></p>
<p>咦，我上游发送的事件，下游一个没收到啊</p>
<p>那么也就是说上游不能发射事件，是因为你没有调用request方法，因为你不调用request（）上游不知道下游能处理事件的能力啊。</p>
<p>那么，也就是说我必须要调用request方法咯，那么我们就调用一下喽，官方说默认推荐使用Long.MAX_VALUE。</p>
<p>好吧，那么我们来试下吧，加上如下代码。</p>
<pre><code>@Override
public void onSubscribe(Subscription s) {
           s.request(Long.MAX_VALUE);  //下游处理事件能力值
               }
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fecqnmh9j4j30gt04ugma.jpg" alt=""></p>
<p>咦，还真正常了啊。</p>
<p>那么，我们设置个2试试？</p>
<pre><code>s.request(2);
</code></pre><p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fecvgzr8hwj30h203owex.jpg" alt=""></p>
<p><strong>也就是说我们下游告诉上游我们能处理2个事件，这样上游就缓存池中取出了2个事件给发送给了下游。这点相比Rxjava1.0可以说是智能了很多，并不会一股脑的抛给下游而是又下游来主动拉取事件。</strong></p>
<p><br><br><br></p>
<h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><p><br></p>
<p>Flowable既然可以跑了，那么咱们就来试试背压吧，我们还是采用BackpressureStrategy.ERROR这个策略，如果下游处理不过来就抛出异常。</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
        @Override
        public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
            for (int i = 0;i&lt; 128; i++) {
                Log.d(TAG, &quot;emit &quot; + i);
                emitter.onNext(i);
            }
        }
    }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Subscriber&lt;Integer&gt;() {

                @Override
                public void onSubscribe(Subscription s) {
                    Log.d(TAG, &quot;onSubscribe&quot;);

                }

                @Override
                public void onNext(Integer integer) {
                    Log.d(TAG, &quot;onNext: &quot; + integer);
                }

                @Override
                public void onError(Throwable t) {
                    Log.w(TAG, &quot;onError: &quot;, t);
                }

                @Override
                public void onComplete() {
                    Log.d(TAG, &quot;onComplete&quot;);
                }
            });
</code></pre><p>我们，首先让上游发送128个事件，下游不做处理，恩好吧是正常的</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fecs2vpr70j30j805g0th.jpg" alt=""></p>
<p>现在我们把128改成129，怎么就异常了呢？<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fecs1pjvg9j311r06umy7.jpg" alt=""></p>
<p>好吧，还是看源码吧</p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fecs5g0z11j30im04dglo.jpg" alt=""></p>
<p>纳尼，原来Flowable的缓存池的最大大小是128吧，如果缓存池里有超过128个事件就会抛出异常，提示你去处理这些事件。<br><br><br><br></p>
<h4 id="MISSING"><a href="#MISSING" class="headerlink" title="MISSING"></a>MISSING</h4><p>那么，<strong>MISSING</strong>和ERROR有什么区别呢？</p>
<p> 我们把缓存策略设置为BackpressureStrategy.MISSING试一下</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
        for (int i = 0;i&lt; 129; i++) {
            Log.d(TAG, &quot;emit &quot; + i);
            emitter.onNext(i);
        }
    }
}, BackpressureStrategy.MISSING).subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {

            @Override
            public void onSubscribe(Subscription s) {
                Log.d(TAG, &quot;onSubscribe&quot;);
                subscription = s;
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;onNext: &quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
                Log.w(TAG, &quot;onError: &quot;, t);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;onComplete&quot;);
            }
        });
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fecscuntdlj30zz04bwf1.jpg" alt=""><br>结构还是一样的，不过这次很友好的提示你队列满了</p>
<pre><code>io.reactivex.exceptions.MissingBackpressureException: Queue is full?!
</code></pre><p>下面是MISSING策略的备注：</p>
<pre><code>/**
* OnNext events are written without any buffering or dropping.
* Downstream has to deal with any overflow.
* &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.
*/
</code></pre><p>也就是说，这种策略是不丢弃，不缓存的策略，那么我要你也没什么用啊…………<br><br><br><br></p>
<p><strong>BUFFER</strong></p>
<p>BUFFER是一个无限大的缓存池，也就是说我们可以往里面存储无限多的事件</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
       @Override
       public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
           for (int i = 0;i&lt;129 ; i++) {
               Log.d(TAG, &quot;emit &quot; + i);
               emitter.onNext(i);
           }
       }
   }, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.io())
           .observeOn(AndroidSchedulers.mainThread())
           .subscribe(new Subscriber&lt;Integer&gt;() {

               @Override
               public void onSubscribe(Subscription s) {
                   Log.d(TAG, &quot;onSubscribe&quot;);

               }

               @Override
               public void onNext(Integer integer) {
                   Log.d(TAG, &quot;onNext: &quot; + integer);
               }

               @Override
               public void onError(Throwable t) {
                   Log.w(TAG, &quot;onError: &quot;, t);
               }

               @Override
               public void onComplete() {
                   Log.d(TAG, &quot;onComplete&quot;);
               }
           });
</code></pre><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fecsyf5izmj30lz06lab1.jpg" alt=""></p>
<p>但是，如果我们发送无数多的事件，同样要注意内存情况。</p>
<p><br><br><br></p>
<h4 id="DROP和LATEST"><a href="#DROP和LATEST" class="headerlink" title="DROP和LATEST"></a>DROP和LATEST</h4><p><strong>首先我们看下Drop</strong></p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
        @Override
        public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
            Log.d(TAG, &quot;requested: &quot; + emitter.requested());
            for (int i = 0; ; i++) {
                emitter.onNext(i);

            }
        }
    }, BackpressureStrategy.DROP).subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Subscriber&lt;Integer&gt;() {

                @Override
                public void onSubscribe(Subscription s) {
                    Log.d(TAG, &quot;onSubscribe&quot;);
                    subscription = s;

                }

                @Override
                public void onNext(Integer integer) {
                    Log.d(TAG, &quot;onNext: &quot; + integer);
                }

                @Override
                public void onError(Throwable t) {
                    Log.w(TAG, &quot;onError: &quot;, t);
                }

                @Override
                public void onComplete() {
                    Log.d(TAG, &quot;onComplete&quot;);
                }
            });
</code></pre><p>我们把对象subscription放到外面，在外面调用request方法（让事件往下面传递，上面说过！！！），看下输出情况。<br>每次点击界面上的按钮触发下面的操作。</p>
<p><strong>假装有按钮</strong></p>
<pre><code>subscription.request(64);
</code></pre><p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fectnf48hbg30hg0b4tl6.gif" alt=""></p>
<p>可以看到，刚进入时打印了当前的request大小，默认为缓存池的大小128.</p>
<p>当我们点击按钮触发subscription.request(64)时，它会从缓存池中取出64个事件发送给下游，当我们呢再次点击，它又取出了64条。但是，当我们第三次点击按钮时，看到了上面令我们诧异的结果。为什么呢？</p>
<blockquote>
<p>FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(64)的时候,下游便会处理掉这64个事件，当第二次请求时把水缸里剩余的64个事件清空, 那么上游水缸中又会重新装进新的128个事件。</p>
</blockquote>
<p>也就是说，我先存128个，当这128个被清空后从新再装进128吧，那么中间这个过程中上游发送的事件，下游就给全部丢掉了。</p>
<p><strong>再来看下LATEST</strong></p>
<p>其实，LATEST和DROP很像都是存不下可就不存，丢事件呗，但是LATEST存储的是最后发送的事件。</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
      @Override
      public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception {
          Log.d(TAG, &quot;requested: &quot; + emitter.requested());
          for (int i = 0;i&lt;1000 ; i++) {
              emitter.onNext(i);

          }
      }
  }, BackpressureStrategy.LATEST).subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())
          .subscribe(new Subscriber&lt;Integer&gt;() {

              @Override
              public void onSubscribe(Subscription s) {
                  Log.d(TAG, &quot;onSubscribe&quot;);
                  subscription = s;

              }

              @Override
              public void onNext(Integer integer) {
                  Log.d(TAG, &quot;onNext: &quot; + integer);
              }

              @Override
              public void onError(Throwable t) {
                  Log.w(TAG, &quot;onError: &quot;, t);
              }

              @Override
              public void onComplete() {
                  Log.d(TAG, &quot;onComplete&quot;);
              }
          });
</code></pre><p>仅仅把策略改成了LATEST,把事件循环设成了1000（因为不设置成固定值，将无法比较和Drop的区别），因为它只保存最后发送的事件</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fecue99ifcg30hg0b4dk0.gif" alt=""></p>
<p>可以看到，它把最后发送的999给存储了下来，至于为什么第三次点击按钮只打印了一个，其实也很简单，由于其他事件早已经发送出去了，事件发送的事件完成的比较快，也就是说当我们第三点击按钮的时候上游的发送事件都已经完成了，所以系统就给我们了最后发送的事件，如果当我们点击按钮的时候事件还没有发送完成，那么他会把正在发送的127个事件和最后的事件发送给下游。</p>
<p>什么？你又不信?<br>在发送的for循环里添加一个延时</p>
<pre><code>Thread.sleep(10);
</code></pre><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fecv5vm821g30hg0b414j.gif" alt=""></p>
<p>看最后的结果</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fecv5en5goj30hk09pjt2.jpg" alt=""></p>
<p><br><br><br></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 你以为我会老老实实给你写总结？<br></p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fecqi5oc27j308c08cq3f.jpg" alt=""></p>
<blockquote>
<p>首先我们需要明白阻塞形成的原因，再想办法和解决阻塞。其实从RxJava2.0背压的策略来看真的比RxJava1.0提升了很多，但是真的没有我们想象的那么完美，因为毕竟丢失的事件不一定使我们想要丢失事件，背压不一定就是你的救命稻草，所以正如上面所演示的根据自己的实际需求制定自己的防阻塞策略很关键。</p>
</blockquote>
<p><br><br><br><br><br><br><br><br><br><br><br><br>是的，我写了,我老老实实写的！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[属性动画入门实践]]></title>
      <url>http://flyou.ren/2017/03/02/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说道动画肯定要先介绍一下，逐帧动画(frame-by-frame animation)和补间动画(tweened animation)。<br>逐帧动画和补间动画是Android出生时就具有的动画。所谓的补间动画就是一个视图上在指定的时间和时间长度下显示某张图片，一般用于加载动画或者做一些简单的展示。<br><br>所谓的补间动画也很简单，学习过flash的读者肯定会很熟悉此类动画，因为它基本和flash的动画模式是一样的，可以对一个元素或者视图做透明度、缩放、平移、旋转动画，当然你也可以把四类组合起来使用完成比较炫酷的效果<br></p>
<p>不过，你以为我给你具体介绍下上面两种动画的用法？<br><br>你想太多了，我可没说今天要讲那玩意，需要的自行google去</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd72y1al3uj309p06c748.jpg" alt=""></p>
<h3 id="什么是属性动画"><a href="#什么是属性动画" class="headerlink" title="什么是属性动画"></a>什么是属性动画</h3><p>属性动画是google在Android3.0以后加入的新的动画机制，为什么叫属性动画呢？因为它是根据对象的属性来改变属性的值，最终达到属性动画的效果。<br><br>这么说所有的对象都可以使用属性动画？对的，只要该对象具有相应属性并具有相应的的get和set方法就可以根据自己的需求来实现的自己的动画。<br>那么属性动画又有什么<strong>优点</strong>呢？</p>
<ul>
<li>所有对象都支持</li>
<li>view的坐标随着动画一起移动</li>
<li>更多的插值器，并支持自定义</li>
<li>配置方便自定义程度高</li>
</ul>
<p>说了这么多，还是来看看怎么用吧</p>
<h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>值动画是属性动画中最基本也是最重要的一个类，因为属性动画是基于属性值改变来完成的，具体为什么这么重要，看下面的图就知道了。</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fd73rs72txj30k306o0tl.jpg" alt=""><br>从图中我们可以很清楚的看到，ValueAnimator可以设置插值器（TimeInterpolator）、值评估器（TypeEvaluator）、时间（duration）、以及开始值和结束的值，设置监听等。</p>
<pre><code> ValueAnimator valueAnimator = new ValueAnimator().ofFloat(0, 500);
valueAnimator.setDuration(3000);
valueAnimator.start();
</code></pre><p>当然我们可以根据需要使用OfInt（）、ofFloat()、ofArgb（）、ofObject()完成不同的效果，当然里面可以传递多个参数值，这些值会在次序执行。</p>
<p>如上所示简单的几行语句就可以实现一个值动画，就是将值在3秒钟从0过渡到500，但是如何使用这个动画呢？<br><br>从上面的图中我们可以可到ValueAnimator 中的UpdateListener，我们可以根据这个监听回调获得我我们想要的值，如何做呢?</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd75jxkyy9j308c08cweh.jpg" alt=""></p>
<p>布局文件很简单，一个textView显示坐标，一个图片用来作用动画，还有一个按钮，不再贴出<br></p>
<pre><code>ValueAnimator valueAnimator = new ValueAnimator().ofFloat(0, 500);
   valueAnimator.setDuration(3000);
   valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
       @Override
       public void onAnimationUpdate(ValueAnimator valueAnimator) {
           float animatedValue = (float) valueAnimator.getAnimatedValue();
           imageView.setTranslationY(animatedValue);
           text.setText(&quot;imageView X:&quot; + imageView.getY());
       }
   });
   valueAnimator.start();
</code></pre><p>上面的代码很简单，给刚才的动画设置了一个监听，当动画值发生改变时设置给ImageView。<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fd760tzsrcg30go0engxj.gif" alt=""></p>
<p>可以看到小炸弹的默认Y坐标是217，在经过3秒后他的坐标增加到了717.</p>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ObjectAnimator是ValueAnimator的子类，ObjectAnimato可以对任意对象进行操作，使用ObjectAnimato可以帮助我们很轻易的完成对任意对象的动画操作，比如View的alpha、scaleX、scaleY、rotationX、rotationY、translationX、translationY、X、Y等。<br><br>为什么我们可以使用View的这些属性呢？因为它在View重定义的有，如下部分：<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fd7gdhznkoj30ge0dogmm.jpg" alt=""></p>
<p>例如    ：<br></p>
<ul>
<li>实现对View的缩放操作。</li>
</ul>
<pre><code>objectAnimator = new ObjectAnimator()
.ofFloat(image, &quot;scaleX&quot;, 1f, 0f, 1f);
objectAnimator.setDuration(2000);
objectAnimator.start();
</code></pre><ul>
<li>实现对View的旋转操作。</li>
</ul>
<pre><code>objectAnimator = new ObjectAnimator()
        .ofFloat(image, &quot;rotationX&quot;, 0, 360);
        objectAnimator.setDuration(2000);
        objectAnimator.start();
</code></pre><ul>
<li>实现对View的透明度操作</li>
</ul>
<pre><code>objectAnimator = new ObjectAnimator()
      .ofFloat(image, &quot;alpha&quot;, 1f, 0f, 1f);
      objectAnimator.setDuration(2000);
      objectAnimator.start();
</code></pre><ul>
<li>实现对View的位移操作</li>
</ul>
<pre><code>objectAnimator = new ObjectAnimator()
.ofFloat(image, &quot;scaleX&quot;, 1f, 0f, 1f);
objectAnimator.setDuration(2000);
objectAnimator.start();
</code></pre><p><strong>当然，我们还可以借助于animatorSet完成组合动画的操作，并控制动画播放的顺序</strong></p>
<ul>
<li>实现组合动画</li>
</ul>
<pre><code>ObjectAnimator alpha = new ObjectAnimator()
        .ofFloat(image, &quot;alpha&quot;, 1f, 0, 1);
        ObjectAnimator translationX = new ObjectAnimator()
        .ofFloat(image, &quot;translationX&quot;, 0, 300, 0);
        ObjectAnimator rotationX = new ObjectAnimator()
        .ofFloat(image, &quot;rotationX&quot;, 0, 360);
        AnimatorSet animatorSet = new AnimatorSet();
        animatorSet.setDuration(3000);
        animatorSet.playTogether(alpha, translationX, rotationX);
        animatorSet.start();
</code></pre><p>透明度变化动画：从完全不透明到透明再到完全不透明<br><br>平移动画：将坐标从现在位置向X正方向偏移300然后再变到0<br><br>旋转动画：将View旋转360°<br><br>然后设置三个动画一起播放</p>
<ul>
<li>实现次序播放控制</li>
</ul>
<pre><code>ObjectAnimator alpha1 = new ObjectAnimator()
        .ofFloat(image, &quot;alpha&quot;, 1f, 0.2f);
        ObjectAnimator alpha2 = new ObjectAnimator()
        .ofFloat(image, &quot;alpha&quot;, 0.2f, 1f);
        ObjectAnimator translationX1 = new ObjectAnimator()
        .ofFloat(image, &quot;translationX&quot;, 0, 300);
        ObjectAnimator translationX2 = new ObjectAnimator()
        .ofFloat(image, &quot;translationX&quot;, 300, 0);
        ObjectAnimator rotationX1 = new ObjectAnimator()
        .ofFloat(image, &quot;rotationX&quot;, 0, 360, 0);
        AnimatorSet animatorSet1 = new AnimatorSet();
        animatorSet1.setDuration(2000);
        animatorSet1.play(alpha1).before(translationX1);
        animatorSet1.play(rotationX1).after(alpha1);
        animatorSet1.play(rotationX1).before(translationX2);
        animatorSet1.play(translationX2).with(alpha2);
        animatorSet1.start();
</code></pre><p>透明度变化动画1：从完全不透明到0.2<br><br>透明度变化动画2：从0.2到透明再到完全不透明<br><br>平移动画1：将坐标从现在位置向X正方向偏移300<br><br>平移动画2：回到原来位置<br><br>旋转动画：将View旋转360°<br></p>
<p>alpha1–&gt;rotationX1、translationX1–&gt;translationX2、alpha2</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd7a4plej1g307i0boaz9.gif" alt=""></p>
<h3 id="使用xml文件创建属性动画"><a href="#使用xml文件创建属性动画" class="headerlink" title="使用xml文件创建属性动画"></a>使用xml文件创建属性动画</h3><pre><code>&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
android:valueFrom=&quot;0&quot;  
android:valueTo=&quot;100&quot;  
android:valueType=&quot;intType&quot;/&gt; 
</code></pre><p>或者</p>
<pre><code>&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
android:valueFrom=&quot;1&quot;  
android:valueTo=&quot;0&quot;  
android:valueType=&quot;floatType&quot;  
android:propertyName=&quot;alpha&quot;/&gt; 
</code></pre><p>或者是组合动画： </p>
<pre><code>&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
android:ordering=&quot;sequentially&quot; &gt;  

&lt;objectAnimator  
    android:duration=&quot;2000&quot;  
    android:propertyName=&quot;translationX&quot;  
    android:valueFrom=&quot;-500&quot;  
    android:valueTo=&quot;0&quot;  
    android:valueType=&quot;floatType&quot; &gt;  
&lt;/objectAnimator&gt;  

&lt;set android:ordering=&quot;together&quot; &gt;  
    &lt;objectAnimator  
        android:duration=&quot;3000&quot;  
        android:propertyName=&quot;rotation&quot;  
        android:valueFrom=&quot;0&quot;  
        android:valueTo=&quot;360&quot;  
        android:valueType=&quot;floatType&quot; &gt;  
    &lt;/objectAnimator&gt;  

    &lt;set android:ordering=&quot;sequentially&quot; &gt;  
        &lt;objectAnimator  
            android:duration=&quot;1500&quot;  
            android:propertyName=&quot;alpha&quot;  
            android:valueFrom=&quot;1&quot;  
            android:valueTo=&quot;0&quot;  
            android:valueType=&quot;floatType&quot; &gt;  
        &lt;/objectAnimator&gt;  
        &lt;objectAnimator  
            android:duration=&quot;1500&quot;  
            android:propertyName=&quot;alpha&quot;  
            android:valueFrom=&quot;0&quot;  
            android:valueTo=&quot;1&quot;  
            android:valueType=&quot;floatType&quot; &gt;  
        &lt;/objectAnimator&gt;  
    &lt;/set&gt;  
&lt;/set&gt;  

&lt;/set&gt;  
</code></pre><p><strong>调用</strong></p>
<pre><code>Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);  
animator.setTarget(view);  
animator.start();  
</code></pre><p>由于比较简单，就不再具体说明与演示，具体大家可以自己试下</p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>前面就已经说过，属相动画可以作用任何对象，当然你也可以定义自己的属性，只要对象属性具有set和get方法。</p>
<p>接下来我们以改变Button的宽度。<br><br>首先我们知道，Button 是有setWidth（）和getWidth（）方法的，但是当我们直接对对它做属性动画时却发现没有什么乱用，到底是为什么呢？<br>通过源码我们可以看到Button继承于TextView，而setWidth是TextView和其子类的专属方法，它的作用不是设置View的宽度，而是设置TextView的最大宽度和最小宽度的，这个和TextView的宽度不是一个东西，具体来说，TextView的宽度对应Xml中的android:layout_width属性，而TextView还有一个属性android:width，这个android:width属性就对应了TextView的setWidth方法。</p>
<p>那么，我们该如何通过属性动画来改变Button的宽度呢？</p>
<p>其实很简单只需要在Button外面包一层就好了，在外面设置相应的属性来来改变Button属性。</p>
<pre><code> private static class ViewWrapper {
    private View mTarget;

    public ViewWrapper(View target) {
        mTarget = target;
    }

    public int getWidth() {
        return mTarget.getLayoutParams().width;
    }

    public void setWidth(int width) {
        mTarget.getLayoutParams().width = width;
        mTarget.requestLayout();
    }
}
</code></pre><p>调用的地方：</p>
<pre><code>ViewWrapper viewWrapper = new ViewWrapper(button);
   ObjectAnimator objectAnimator = new ObjectAnimator().ofInt(viewWrapper, &quot;width&quot;,buttonWidth,800);
   objectAnimator.setDuration(2000);
   objectAnimator.start();
</code></pre><p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd7k2oy9nug30co02s3zg.gif" alt=""></p>
<p>当然，使用<strong>ValueAnimator</strong>同样可以实现上面的效果</p>
<pre><code>  @Override  
    public void onAnimationUpdate(ValueAnimator animator) {  

        int currentValue = (Integer)animator.getAnimatedValue();  

        button.getLayoutParams().width = buttonWidth+currentValue； 
        button.requestLayout();  
    }  
});  
</code></pre><h2 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h2><p>Interpolator用于动画中的时间插值，其作用就是把0到1的浮点值变化映射到另一个浮点值变化</p>
<p>在属性动画中一共有10中插值器</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd7kovzxzjj30nx06gmyb.jpg" alt=""><br>当然，support包中许多不同场景的插值器，这里我们不在做具体的介绍。</p>
<ul>
<li><p>匀速线性<br>LinearInterpolator:</p>
</li>
<li><p>先加速后减速<br>AccelerateDecelerateInterpolator:</p>
</li>
<li><p>一直加速<br>AccelerateInterpolator:</p>
</li>
<li><p>反向移动然后正向加速<br>AnticipateInterpolator:</p>
</li>
<li><p>加速下落回弹<br>BounceInterpolator:</p>
</li>
<li><p>循环播放 参数指定循环次数<br>CycleInterpolator:</p>
</li>
<li><p>减速效果<br>DecelerateInterpolator:</p>
</li>
<li><p>反向超过原来位置 然后正向加速超过规定位置 返回<br>AnticipateOvershootInterpolator:</p>
</li>
<li><p>向前甩一定值后再回到原来位置  可以传值指定加速度值<br>OvershootInterpolator:</p>
</li>
<li><p>按照一定路径完成相应运动的速度<br>PathInterpolator</p>
</li>
</ul>
<p>具体实现如下：<br>初始化动画：</p>
<pre><code>  private void initView() {
    objectAnimator = new ObjectAnimator().ofFloat(image, &quot;translationY&quot;, 0, 1200);
    objectAnimator.setDuration(3000);
}
</code></pre><p>设置插值器并运行动画：</p>
<pre><code> public void onClick(View view) {
switch (view.getId()) {
    //匀速线性
    case R.id.LinearInterpolator:
        objectAnimator.setInterpolator(new LinearInterpolator());
        break;
    //先加速后减速
    case R.id.AccelerateDecelerateInterpolator:
        objectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
        break;
    //一直加速
    case R.id.AccelerateInterpolator:
        objectAnimator.setInterpolator(new AccelerateInterpolator());
        break;
    //反向移动然后正向加速
    case R.id.AnticipateInterpolator:
        objectAnimator.setInterpolator(new AnticipateInterpolator());
        break;
    //加速下落回弹
    case R.id.BounceInterpolator:
        objectAnimator.setInterpolator(new BounceInterpolator());
        break;
    //循环播放 参数指定循环次数
    case R.id.CycleInterpolator:
        objectAnimator.setInterpolator(new CycleInterpolator(2f));
        break;
    //减速效果
    case R.id.DecelerateInterpolator:
        objectAnimator.setInterpolator(new DecelerateInterpolator());
        break;
    //反向超过原来位置 然后正向加速超过规定位置 返回
    case R.id.AnticipateOvershootInterpolator:
        objectAnimator.setInterpolator(new AnticipateOvershootInterpolator());
        break;
    //向前甩一定值后再回到原来位置  可以传值指定加速度值
    case R.id.OvershootInterpolator:
        objectAnimator.setInterpolator(new OvershootInterpolator());
        break;
    case R.id.PathInterpolator:
        Intent intent=new Intent(InterpolatorActivity.this,InterpolatorPathActivity.class);
        startActivity(intent);
        break;

}
objectAnimator.start();
    }
</code></pre><p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fd7lchfqlfg30dc0kub29.gif" alt=""></p>
<h3 id="PathInterpolator"><a href="#PathInterpolator" class="headerlink" title="PathInterpolator"></a>PathInterpolator</h3><blockquote>
<p>至于<strong>PathInterpolator</strong>这里需要特别做下说明（其他上面的差值器和这个类似，简单的多…），因为它真的很强大，可以实现很多漂亮的效果。</p>
</blockquote>
<p>首先看PathInterpolator 的构造参数里面，可以传入一个path对象、一个控制点或者两个控制点。<br><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fd7oahph7kj30cj040mx4.jpg" alt=""></p>
<p>打开<strong>PathInterpolator的源码</strong>我们可以看到</p>
<pre><code>    //构造函数1
 public PathInterpolator(Path path) {
    initPath(path);
}

       //构造函数2
public PathInterpolator(float controlX, float controlY) {
    initQuad(controlX, controlY);
}

       //构造函数3
public PathInterpolator(float controlX1, float controlY1, float controlX2, float controlY2) {
    initCubic(controlX1, controlY1, controlX2, controlY2);
}
    //这个方法里面的东西是不是很熟悉，没错他就是二阶贝塞尔曲线
 private void initQuad(float controlX, float controlY) {
    Path path = new Path();
    path.moveTo(0, 0);
    path.quadTo(controlX, controlY, 1f, 1f);
    initPath(path);
}
    //当然他就是三阶贝塞尔曲线咯
private void initCubic(float x1, float y1, float x2, float y2) {
    Path path = new Path();
    path.moveTo(0, 0);
    path.cubicTo(x1, y1, x2, y2, 1f, 1f);
    initPath(path);
}
</code></pre><p>可以看待三个构造函数归根结底都是构建了一个Path对象，然后对path进行操作<br><br><strong>initPath()</strong></p>
<pre><code> private void initPath(Path path) {
    float[] pointComponents = path.approximate(PRECISION);

    int numPoints = pointComponents.length / 3;
    if (pointComponents[1] != 0 || pointComponents[2] != 0
            || pointComponents[pointComponents.length - 2] != 1
            || pointComponents[pointComponents.length - 1] != 1) {
        throw new IllegalArgumentException(&quot;The Path must start at (0,0) and end at (1,1)&quot;);
    }

    mX = new float[numPoints];
    mY = new float[numPoints];
    float prevX = 0;
    float prevFraction = 0;
    int componentIndex = 0;
    for (int i = 0; i &lt; numPoints; i++) {
        float fraction = pointComponents[componentIndex++];
        float x = pointComponents[componentIndex++];
        float y = pointComponents[componentIndex++];
        if (fraction == prevFraction &amp;&amp; x != prevX) {
            throw new IllegalArgumentException(
                    &quot;The Path cannot have discontinuity in the X axis.&quot;);
        }
        if (x &lt; prevX) {
            throw new IllegalArgumentException(&quot;The Path cannot loop back on itself.&quot;);
        }
        mX[i] = x;
        mY[i] = y;
        prevX = x;
        prevFraction = fraction;
    }
}
</code></pre><p>path.approximat()方法实际就是调用了Native层的方法，返回了一系列值。包括fraction、X、Y等<br><br>通过这个方法我们就得到了我们想要的fraction，这个fraction是实时变化的。我们可以在addUpdateListener的回调中获取：</p>
<pre><code>valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
       @Override
       public void onAnimationUpdate(ValueAnimator valueAnimator) {

          float animatedFraction = valueAnimator.getAnimatedFraction();

       }
   });
</code></pre><p>animatedFraction这个值是0-1.0f的一个值，描述的是当前动画播放比例，我们回在下面具体介绍。</p>
<pre><code>objectAnimator.setInterpolator(new PathInterpolator(0.8f,0.1f));
</code></pre><p>:</p>
<pre><code>objectAnimator.setInterpolator(new PathInterpolator(0.1f,0.8f));
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fd7q8djrt6g307j0m8woc.gif" alt="">  <img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fd7qd234tdg30800m8dpc.gif" alt=""></p>
<p>这样大概看不出什么效果，还是结合Path动画来看下吧 。</p>
<p><strong>首先创建Path动画</strong></p>
<pre><code>Path path = new Path();
path.moveTo(X,Y);
path.quadTo(800, Y, 800, 800);
ObjectAnimator objectAnimator1 = new ObjectAnimator().ofFloat(image, &quot;x&quot;, &quot;y&quot;, path);
objectAnimator1.setDuration(3000);
objectAnimator1.start();
</code></pre><p>上面看到创建的path 将起点定在view的初始位置（X,Y），控制点为(800,Y),结束点为（800,800）<br><br>假设x=y=100</p>
<pre><code>Path path = new Path();
path.moveTo(100,100);
path.quadTo(800, 100, 800, 800);
</code></pre><p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fd8e61n6dcj30c80c8aa3.jpg" alt=""></p>
<p>更好的演示贝塞尔曲线可以看下面的动画，图示的坐标点为控制点（好像有点偏题了了….，这个自定义的View见文底Demo）<br><br>当然如果想进一步学习和了解贝塞尔曲线的可自行google，附上常用贝塞尔曲线<a href="http://cubic-bezier.com" target="_blank" rel="external">在线演示地址</a></p>
<p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fd8e4jjrb0g30c90c8e0k.gif" alt=""></p>
<p>中间的曲线可以随着参数的改变来改变，那么到底是不是这个样子呢？</p>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tgy1fd7rapyd3gg30dw0cowid.gif" alt=""></p>
<p>好吧，我们回到动画上，接下来我们给他加上PathInterpolator 制定了连个控制点</p>
<p>objectAnimator1.setInterpolator(new PathInterpolator(0.9f,0.1f,0.5f,0.9f));</p>
<p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fd7reu5itgg30dw0cygpl.gif" alt=""></p>
<p>当然你也可以使用连个控制点来完成不同的加速度效果，其实上面路径的曲线效果就类似与动画的加速度效果。</p>
<p>PathInterpolator就先介绍到这里，接下来看下Evaluator</p>
<h2 id="Evaluator"><a href="#Evaluator" class="headerlink" title="Evaluator"></a>Evaluator</h2><p>Evaluator是值评估器的意思，帮助你很好的完成属性值的计算工作，当然你可以自定义自己的值评估器来完成自己的需要<br>下面是IntEvaluator的源码，可以看到这里有个亿参数叫做fraction，fraction就是上面我们提到的进度比例。</p>
<pre><code>public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; {
  @Override
public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
    int startInt = startValue;
    return (int)(startInt + fraction * (endValue - startInt));
}
</code></pre><p>这里首选获取开始的值，然后加上结束减去中间再乘以进度比例就获得了现在的值。如果起始值为0，那么上面的公式就变成了：</p>
<pre><code> public Integer evaluate(float fraction, Integer startValue, Integer endValue) {

    return (int)（fraction * endValue）;
}
</code></pre><p>那么如果我想让接受方的值扩大5倍怎么办？</p>
<p>当然是直接在这里乘以5就行了，这样外面接受属性值得地方，接收的值就扩大了5倍</p>
<pre><code>@Override
    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
    int startInt = startValue;
    return (int)(startInt + fraction * (endValue - startInt))*5;
}
</code></pre><h3 id="如何自定义Evaluator"><a href="#如何自定义Evaluator" class="headerlink" title="如何自定义Evaluator"></a>如何自定义Evaluator</h3><p>由IntEvaluator的源码我们可以看到其实现了TypeEvaluator<t>接口，并复写了evaluate函数。</t></p>
<p>那么我们也可以根据这个来自定义自己的估值器。</p>
<p>首先，我们有这样一个场景，学生的年龄年龄从出生到22岁每年增长一岁，学生的体重从出生时的40cm到22岁188cm。<br>Stduent：</p>
<pre><code>public class Student {
       private int age;
       private int height;

public Student(int age, int height) {
    this.age = age;
    this.height = height;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}

public int getHeight() {
    return height;
}

public void setHeight(int height) {
    this.height = height;
}
}
</code></pre><p>StudentEvaluator：自定义估值器，获取对象并作用后返回。</p>
<pre><code>public class StudentEvaluator implements TypeEvaluator&lt;Student&gt; {

@Override
public Student evaluate(float fraction, Student startValue, Student endValue) {
    int startAge = startValue.getAge();
    int startHeight = startValue.getHeight();
    int endAge = endValue.getAge();
    int endHeight = endValue.getHeight();

    int currentAge = (int) (startAge + fraction * (endAge - startAge));

    int currentHeight = (int) (startHeight + fraction * (endHeight - startHeight));

    return new Student(currentAge, currentHeight);
}
}
</code></pre><p>使用估值器：</p>
<pre><code>  ValueAnimator valueAnimator=new ValueAnimator().ofObject(new StudentEvaluator(),
    new Student(0,40),new Student(22,188));
    valueAnimator.setDuration(5000);
    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            Student student = (Student) animation.getAnimatedValue();
            info.setText(&quot;age:&quot;+student.getAge()+&quot;,height:&quot;+student.getHeight());
        }
    });
valueAnimator.start();
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fd7t3rupptg30go04z430.gif" alt=""></p>
<p>但是，这样是有前提的啊，前提是学生只能活到22岁，该学生好可悲啊，那么好把，让你活久一点。</p>
<pre><code>ValueAnimator valueAnimator=new ValueAnimator().ofObject(new StudentEvaluator(),
    new Student(0,40),new Student(100,188));
</code></pre><p><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fd8a03vkx6g30go04djw8.gif" alt=""></p>
<p>他妈的，这孩子想干啥，虽然长得慢但是也不能一直长啊，纳尼。<br><br>可以发现，无论我们在外面怎么更改，也不能达到我们想要的效果，所以我们只能从StudentEvaluator出发、</p>
<pre><code>  @Override
public Student evaluate(float fraction, Student startValue, Student endValue) {
    int startAge = startValue.getAge();
    int startHeight = startValue.getHeight();
    int endAge = endValue.getAge();
    int endHeight = endValue.getHeight();

    int currentAge = (int) (startAge + fraction * (endAge - startAge));

    int currentHeight = (int) (startHeight + fraction * (endHeight - startHeight));
    if (currentAge&gt;=22){
      currentHeight=188;
    }

    return new Student(currentAge, currentHeight);
}
</code></pre><p>我们可以让使用该估值器的地方随便填写，当然年龄我们就不做限制了，我们这里仅对身高做限制，一般来说年龄到达22就不让他增长了，身高我们暂且都给一个188吧，哈哈。<br>当然，这个估值器里面还存在很多的问题，比如我要是年龄到22了身高没到188怎么办？身高和年龄的成长速度关系等……</p>
<p>估值器先介绍到这里，当然你可以根据自己的业务逻辑完成自己的估值器。</p>
<h2 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h2><p>在3.0以后同样增加的就是ViewPropertyAnimator，总的来说应该也属于属性动画的范畴吧，它的用法比ObjectAnimator更加方便（但是我还是比较上面的方式）</p>
<p>下面是ViewPropertyAnimator的一些特点（<a href="http://blog.csdn.net/guolin_blog/article/details/44171115" title="引用" target="_blank" rel="external">引用</a>）。</p>
<blockquote>
<ul>
<li>整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。</li>
</ul>
<ul>
<li>在使用ViewPropertyAnimator时，我们无需调用start()方法，因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。</li>
</ul>
<ul>
<li>ViewPropertyAnimator的所有接口都是使用连缀的语法来设计的，每个方法的返回值都是它自身的实例，因此调用完一个方法之后可以直接连缀调用它的另一个方法，这样把所有的功能都串接起来，我们甚至可以仅通过一行代码就完成任意复杂度的动画功能。</li>
</ul>
</blockquote>
<p>事例：</p>
<pre><code>imageview.animate().x(500).y(500).alpha(0.8f)setDuration(5000); 

imageview.animate().x(500).y(500).alpha(0.8f)setDuration(5000); 

    go.animate().setInterpolator(new LinearInterpolator()).rotationBy(360).scaleXBy(0.1f).translationZ(30).setDuration(3000)
</code></pre><p>但是，里面新增了相应的以By的结尾的方法，当然就是从现在状态执行相应值，translationZ（）指的是Z轴方向的偏移两<br>是在API21才加入的方法</p>
<p>举个栗子：</p>
<p>点击按钮时让image的Y坐标向下移动300像素，让image旋转720度：</p>
<pre><code>public void onClick() {
    image.animate().translationY(300).rotation(720).setDuration(3000);
}
</code></pre><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fd88o5wedcg30cs0b9jxi.gif" alt=""></p>
<p>可以看到第一次点击，iamge向下面移动了300像素并伴随着720°的旋转，可以当后面再点击时，发现image并没有任何变化。</p>
<p>那么，现在我们就需要考虑下以By结尾的方法了。</p>
<pre><code> public void onClick() {
    image.animate().translationYBy(300).rotationBy(720).setDuration(3000);
}
</code></pre><p><img src="http://ww2.sinaimg.cn/large/0060lm7Tgy1fd88wfz0jcg30ci0iftm9.gif" alt=""></p>
<p>那么，再来看下Z和translationZBy（），下面就用translationZBy（）来作说明。</p>
<pre><code>  public void onClick() {
    go.animate().translationZBy(30f);
}
</code></pre><p>每次点击，我们让按钮在Z轴的偏移量增加30,效果如下<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fd892e9i3fg30ex04bgu0.gif" alt=""></p>
<p>当然，我们依然可以给动画设置Listener、UpdateListener、和插值器Interpolator，这些做法和上面讲到的用法一样，就不再具体说明，有兴趣的童鞋可以自己去尝试。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>怎么样，学完属性动画是不是已经爱上它了？没有也没关系，先用起来吧，相信你试过以后一定会爱上我，不，是它，是它！。<br><br>赶脚还有很多东西没写，但是这篇文章真的写了好久了，先这样吧，以后会分析一些真正关于属性动画相关实践的东西。</p>
<p>最后照例：<a href="https://github.com/flyou/PropertyAnimatorDemo" target="_blank" rel="external">Demo地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dagger2入门]]></title>
      <url>http://flyou.ren/2017/01/13/Dagger2%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>众所周知Dagger是一个依赖注入(Dependency Injection)框架简称DI，那么什么是依赖注入呢？其实熟悉Spring的小伙伴应该都非常清楚，因为Spring的核心思想就是依赖注入，管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。</p>
<p>那么到底什么是依赖注入呢？</p>
<blockquote>
<p>对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。也就是说，被注入的对象不需要重复的初始化就可以获得相应的引用。</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcituqblytj20go0go0ss.jpg" alt=""></p>
<p>比如说小明去超市买酱油，这样我们肯定需要一个小明的对象和酱油的对象。</p>
<p>物品基类</p>
<pre><code>public class Things{

}  
</code></pre><p>酱油类</p>
<pre><code>public class Sauce extend Things{

public void sauce(String type,float price){

    }
}
</code></pre><p>小明类</p>
<pre><code>public class XiaoMing {
Things sauce=new Sauce(&quot;海天&quot;，5.6$);

/**
 * 买的动作
 * @param object
 */
private  void buy(Things things){
……
……
}
……
…………
………………
}
</code></pre><p>代码看起来貌似没有什么大问题，但是可以注意酱油在小明类中高度耦合，也就是说明天小明不打酱油了，去买毛线的时候小明这个类就要发生更改，后天买棒棒糖的时候当然也需要更改，这样下来小明没累死，我累死了。</p>
<p>如果使用依赖注入就不一样了</p>
<p>小明类</p>
<pre><code>public class XiaoMing {
@Inject
Things things;

/**
 * 买的动作
 * @param object
 */
private  void buy(Things things){
……
……
}
……
…………
………………
}
</code></pre><p>我们根本不需要关注小明究竟买什么，也不用关注买的东西的颜色、大小、价格。也就是说被注入的地方会自动获得一个初始化好的对象。</p>
<h2 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h2><h3 id="Dagger2简介"><a href="#Dagger2简介" class="headerlink" title="Dagger2简介"></a>Dagger2简介</h3><p>Dagger2是Dagger1的分支，由谷歌公司接手开发，目前的版本是2.0。Dagger2是受到AutoValue项目的启发。Dagger是依赖注入的一种，说到依赖注入，标准定义是目标类中所依赖的其他的类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以把其他的类的已经初始化好的实例自动注入到目标类中。说简单就是一次构建，到处注入。</p>
<h3 id="使用Dagger2的好处"><a href="#使用Dagger2的好处" class="headerlink" title="使用Dagger2的好处"></a>使用Dagger2的好处</h3><ol>
<li><p>依赖的注入和配置独立于组件之外。</p>
</li>
<li><p>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</p>
</li>
<li><p>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</p>
</li>
</ol>
<h3 id="Dagger2基本组成"><a href="#Dagger2基本组成" class="headerlink" title="Dagger2基本组成"></a>Dagger2基本组成</h3><ul>
<li>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</li>
<li>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的 依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</li>
<li>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</li>
<li>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。</li>
</ul>
<h3 id="Dagger2简单入门"><a href="#Dagger2简单入门" class="headerlink" title="Dagger2简单入门"></a>Dagger2简单入门</h3><ul>
<li>引入Dagger</li>
</ul>
<p>首先在项目根目录的 build.gradle文件中引入apt</p>
<pre><code>buildscript {
repositories {
    jcenter()
}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.2.3&apos;
    //引入相应apt
    classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;
    }
}

allprojects {
repositories {
    jcenter()
}
}
</code></pre><p>然后在所在module的build.gradle做如下配置</p>
<pre><code>//首先引入 apt
apply plugin: &apos;com.neenbedankt.android-apt&apos;
……
……
dependencies {
//java注解
provided &apos;javax.annotation:javax.annotation-api:1.2&apos;
//dagger2
compile &apos;com.google.dagger:dagger:2.5&apos;
//dagger编译器
apt &apos;com.google.dagger:dagger-compiler:2.5&apos;
}
</code></pre><ul>
<li>简单例子</li>
</ul>
<p>下面继续举个简单的栗子。<br>把User对象的值赋值到Activity里去。<br>代码的简单结构如下</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj93ewswoj208q04rt8w.jpg" alt=""></p>
<p>User类</p>
<pre><code>public class User {
private String name;
private int age;

public User() {
}

public User(String name, int age) {
    this.name = name;
    this.age = age;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}
}
</code></pre><p>UserModule类</p>
<pre><code>@Module//标识该类提供依赖
public class UserModule {
@Provides//告诉Dagger我们想要构造对象并提供这些依赖
User provideUser() {
    return new User(&quot;周杰伦&quot;, 38);
}
}
</code></pre><p>UserComponent类</p>
<pre><code>//Component 链接被注入的地方和提供依赖的地方
@Component(modules = UserModule.class)
public interface UserComponent {
void inject(DaggerActivity activity);
}
</code></pre><p><strong>这个时候简单的注入就基本完成了，但是我们注意到Component文件是一个接口文件，我们肯定无法直接使用，现在我们需要借助于Dagger让它帮助我们根据注解生成对象</strong></p>
<p>点击android studio的工具栏的 make progect</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj9j67r96j20ff01h74j.jpg" alt=""></p>
<p>或者</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1fcj9jxg4n8j207i08q0tr.jpg" alt=""></p>
<p>就会在bulid文件夹下生成相应的文件如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcj9l6t8bpj20c00abt9j.jpg" alt=""></p>
<p>当然我们用到的暂时只有以Dagger开头的Component文件，这个时候我们就可以在activity中使用完成User的注入了</p>
<p>DaggerActivity类</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
//需要注入User对象
@Inject
User user;
UserComponent userComponent;
private TextView textView;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    //完成对User的注入
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    //根据注入的User对象设置TextView
    textView.setText(user.getName()+&quot;:&quot;+user.getAge());
}
}
</code></pre><p>布局文件就不在放出来了，就是一个简单的textview。具体效果如下。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcj9unkwyhj20u00fegme.jpg" alt=""></p>
<p>这样我们就完成了Dagger的一个简单的注入，下面会介绍Dagger的一些进一步的用法</p>
<h3 id="Dagger2深入学习"><a href="#Dagger2深入学习" class="headerlink" title="Dagger2深入学习"></a>Dagger2深入学习</h3><h4 id="Singleton-使用该注解实现单例的效果"><a href="#Singleton-使用该注解实现单例的效果" class="headerlink" title="@Singleton 使用该注解实现单例的效果"></a>@Singleton 使用该注解实现单例的效果</h4><p>还是上面的栗子，如果我们在Activity中注入两个User对象</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
@Inject
User user1;
@Inject
User user2;

UserComponent userComponent;
private TextView textView;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    textView.setText(&quot;user1--&gt;&quot;+user1.toString()+&quot;\nuser2--&gt;&quot;+user2);

}
}
</code></pre><p>然后对比两者的地址。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcjam2ptdkj20u00gzac7.jpg" alt=""></p>
<p>可以发现两者的地址并不相同，可见Dagger为我们生成了两个对象，但是我们有时候并不需要两个对象，如一些全局的配置<br>SharedPreferences 对象、数据库管理对象等，要是在平时我们就必须自己通过手写单例来实现，但是使用Dagger的@Singleton 注解我们就可以很轻松的完成对象的单例，而丝毫不用考虑单例如何实现。</p>
<p>UserModule类</p>
<pre><code>@Module
public class UserModule {
@Singleton
@Provides
User provideUser() {
    return new User(&quot;周杰伦&quot;, 38);
    }
}
</code></pre><p>UserComponent类</p>
<pre><code>@Singleton
@Component(modules = UserModule.class)
public interface UserComponent {
void inject(DaggerActivity activity);
}
</code></pre><p>只需要一个简单的注解就可以实现单例。这时候我们需要重新点击 make project来重新生成编译注解。</p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1fcjassogqpj20u00htgnr.jpg" alt=""></p>
<p>再次运行，我们可以看到这次Dagger只为我们生成了一个对象。</p>
<h4 id="Scope-Scopes自定义注解作用域"><a href="#Scope-Scopes自定义注解作用域" class="headerlink" title="@Scope: Scopes自定义注解作用域"></a>@Scope: Scopes自定义注解作用域</h4><p>Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。如PerApp、perActivity等</p>
<p>PerActivity</p>
<pre><code>@Scope
@Retention(RUNTIME)
public @interface PerActivity {}
</code></pre><p>PerApp</p>
<pre><code>@Scope
@Retention(RUNTIME)
public @interface PerApp {}
</code></pre><p>该自定义注解需要同时在Module和component中使用才会起作用，会在下面的栗子中进一步说明。</p>
<h4 id="其他相关注解"><a href="#其他相关注解" class="headerlink" title="其他相关注解"></a>其他相关注解</h4><p>@Qualifier限定符，可以对注解做出一定的限定，具体可以参照java相关注解。</p>
<p>懒加载 lazy 即在等到调用的时候才注入。<br>在使用的地方使用user.get()就能得到一个User对象</p>
<pre><code>public class DaggerActivity extends AppCompatActivity {
@Inject
Lazy &lt;User&gt; user;

UserComponent userComponent;
private android.widget.TextView textView;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dagger);

    this.textView = (TextView) findViewById(R.id.textView);
    userComponent = DaggerUserComponent.builder().build();
    userComponent.inject(this);
    User myUser = this.user.get();
    textView.setText(myUser.getName()+&quot;:&quot;+ myUser.getAge());
}

}
</code></pre><h3 id="Dagger与MVP结合"><a href="#Dagger与MVP结合" class="headerlink" title="Dagger与MVP结合"></a>Dagger与MVP结合</h3><p>上面讲了那么多的Dagger的基础，我们还没有进行真正的运用，接下来我们就结合MVP（如果不知道什么是MVP的话，自行Gogle）来一起来做一个简单的栗子。</p>
<p>首选看一下简单的代码结构</p>
<p><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1fcjbgzex2nj209l0addgm.jpg" alt=""></p>
<p>可以看到我们仅仅是在原来的MVP结构上新增两个（module和component），与MVP的结合我们主要是用在对persenter的改造上，完成对Persenter的注入。</p>
<p>由上述的代码命名我们可以很容易的看出这是一个简单模拟登陆的栗子，在model层主要完成登陆判断的逻辑，在persenter层主要是对View的控制，在module主要是完成persenter注入提供依赖，在component层主要是协调被注入Activity和module的关系。</p>
<p>User.class</p>
<pre><code>public class User {
private String userName;
private String password;

public User() {
}

public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
}

public String getUserName() {
    return userName;
}

public void setUserName(String userName) {
    this.userName = userName;
}

public String getPassword() {
    return password;
}

public void setPassword(String password) {
    this.password = password;
}
}
</code></pre><p>ILoginModel.class</p>
<pre><code>public interface ILoginModel {

void login(String userName, String password,LoginListener listener);

interface LoginListener {
    void loginSuccess();
    void loginFailed(String msg);
}
}
</code></pre><p>LoginModelImpl.class</p>
<p>完成登陆逻辑，这里可以进行网络操作，完成登陆操作，这次我们仅仅在本地模拟判断用户名和密码，这里使用postDelayed（）来模拟网络操作。</p>
<pre><code>public class LoginModelImpl implements ILoginModel {

@Override
public void login(String userName, String password, LoginListener listener) {
     new Handler().postDelayed(new Runnable() {
        @Override
        public void run() {
    if (userName.equals(&quot;flyou&quot;) &amp;&amp; password.equals(&quot;553274238&quot;)) {
        listener.loginSuccess();
    } else {
        listener.loginFailed(&quot;用户名密码错误&quot;);
    }
      },2000);
}
}
</code></pre><p>ILoginView.class</p>
<p>提供视图相关接口</p>
<pre><code>public interface ILoginView {
void showLoading();
void hideLoading();
void showError(String msg);
void LoginSuccess();
}
</code></pre><p>LoginPersenter.class</p>
<p>完成View和数据的协调。</p>
<pre><code>public class LoginPersenter {
private ILoginView loginView;
private ILoginModel loginModel;

public LoginPersenter(ILoginView loginView) {
    this.loginModel=new LoginModelImpl();
    this.loginView = loginView;
}
public void login(final String userName, final String password){
    loginView.showLoading();

            loginModel.login(userName, password, new ILoginModel.LoginListener() {
                @Override
                public void loginSuccess() {
                    loginView.hideLoading();
                    loginView.LoginSuccess();
                }

                @Override
                public void loginFailed(String msg) {
                    loginView.hideLoading();
                    loginView.showError(msg);
                }
            });
        }
       }
}
</code></pre><p>PerApp.class</p>
<p>自定义注解范围</p>
<pre><code>@Scope
@Documented
@Retention(RetentionPolicy.RUNTIME)

public @interface PerApp {
}
</code></pre><p>LoginPersenterModule.class</p>
<p><strong>和上面简单的例子一样我们需要使用LoginPersenter就要完成对LoginPersenter的注入，唯一不同就是这里的我们是这里我们依赖的LoginPersenter需要参数，那么我们再这里就要完成第参数的依赖，如果有多个参数我们就要完成对多个参数的依赖</strong></p>
<pre><code>@Module
public class LoginPersenterModule {
private LoginActivity loginActivity;

public LoginPersenterModule(LoginActivity loginActivity) {
    this.loginActivity = loginActivity;
}
@PerApp
@Provides
LoginActivity provideLoginActivity(){
    return loginActivity;
}

@PerApp
@Provides
LoginPersenter ProvideLoginPersenter(LoginActivity loginActivity){
    return new LoginPersenter(loginActivity);
}
}
</code></pre><p>LoginPersenterCompoent.class<br>完成module与注入地方的关系协调</p>
<pre><code>@PerApp//定义注解范围
@Singleton
@Component(modules = LoginPersenterModule.class)
public interface LoginPersenterCompoent {
void inject(LoginActivity activity);
}
</code></pre><p>LoginActivity.class</p>
<pre><code>public class LoginActivity extends AppCompatActivity implements ILoginView {
@Inject
LoginPersenter loginPersenter;
private LoginPersenterCompoent loginPersenterCompoent;
private android.widget.EditText userName;
ProgressDialog progressDialog;
PasswordToggleEditText2 password;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_login);
    this.password = (PasswordToggleEditText2) findViewById(R.id.password);
    this.userName = (EditText) findViewById(R.id.userName);
    loginPersenterCompoent= DaggerLoginPersenterCompoent.builder()
    .loginPersenterModule(new LoginPersenterModule(this)).build();
    loginPersenterCompoent.inject(this);
}

public void login(View view) {
    loginPersenter.login(userName.getText().toString().trim(),password.getText().toString().trim());

}

@Override
public void showLoading() {
     progressDialog=ProgressDialog.show(LoginActivity.this,&quot;正在登录&quot;,&quot;正在登录请稍后……&quot;,true,false);
}

@Override
public void hideLoading() {
    progressDialog.dismiss();
}

@Override
public void showError(String msg) {
    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
}

@Override
public void LoginSuccess() {
    Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();
}
}
</code></pre><p>布局文件真的很简单，就不再贴出了。</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1fcjx0fejoyg20dc0npqjg.gif" alt=""></p>
<p>到这里，文章就基本结束了，笔者有什么写错的地方欢迎拍砖~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[应用安全之[adb backup]]]></title>
      <url>http://flyou.ren/2016/12/16/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E4%B9%8B%5Badb%20backup%5D/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先讲个故事，小杰喜欢上了公司的女同事，但是却不敢向她要联系方式，偶然间她发现女同事竟然还上探探，于是小杰立刻拿起了手机在自己手机上下载了一个探探。滑了整整一星期都没遇见女同事，屏保都划破了……<br><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/82711797-file_1487230714653_10813.png" alt=""></p>
<p>作为同事的小明终于看不下去了，就提出了要帮他的想法，说可以帮助小杰帮忙把女同事的探探设置自己为暗恋对象，小杰不敢相信但是还是非常虔诚的接受了小明提出的帮助。</p>
<p>一天后，小杰请小明大吃了一顿……</p>
<p>事情的经过是这样的，小明以测试为由说要用女同事的手机，于是女同事就来到小明的座位上，看着小明用自己的手机进行测试，可是小明就敲了几行命令就把手机还给了女同事并连声道谢，不解的女同事寒暄着离开了。然后事情就按照小明所说的发生了……<br><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/56357804-file_1487231323629_17b7d.png" alt=""></p>
<p>##到底发生了什么</p>
<h3 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h3><blockquote>
<p>在谷歌2010年发布Android 2.2 Froyo (冻酸奶)系统中，谷歌引入一个了系统备份的功能，允许用户备份系统应用和第三方应用的apk安装包和应用数据，以便在刷机或者数据丢失后恢复应用。 第三方应用开发者需要在应用的AndroidManifest.xml文件中配置allowBackup标志(默认为true)来设置应用数据是否能能够 被备份或恢复。</p>
<p>当这个标志被设置为true时应用程序数据可以在手机未获取ROOT的情况下通过adb调试工具来备份和恢复，这就允许恶意攻击者在接触用户手机的情况下 在短时间内启动手机USB调试功能来窃取那些能够受到AllowBackup漏洞影响的应用的数据，造成用户隐私泄露甚至财产损失。</p>
</blockquote>
<h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><p>接下来就来讲一下到底发生了什么。</p>
<p>首先小明邀请女同事来到自己的座位，把女同事的手机连接到了自己的PC上,并敲下了如下命令，确保了女同事的手机已经和自己的PC进行了连接</p>
<pre><code>adb devices
</code></pre><p><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/75451917-file_1487231636025_10084.png" alt=""><br>然后敲下了如下命令：</p>
<pre><code>adb backup -nosystem -noshared -apk -f com.tantan.apk com.p1.moblie.putong
</code></pre><p>并在女同事手机上点了个确认按钮，30秒后就把手机还给了女同事。</p>
<p><strong> adb backup</strong>又是什么鬼？</p>
<p>adb backup是adb众多命令中的一个，主要作用是备份手机中的文件，其命令操作如下：</p>
<p>adb backup [-f <file>] [-apk|-noapk] [-shared|-noshared][-all] [-system|nosystem][<packages...>]<br><br>参数简介：<br>代码 -f<file>设置备份后的文件名和路径。比如”C:\dxy.ab”，扩展名是ab。<br><br>代码:-apk|-noapk选择是否备份APK程序本身。<br><br>代码:-shared|-noshared是否备份SD卡。<br><br>代码:-system|-nosystem是否备份系统程序。<br><br>代码:<packages...>指定备份具体的应用程序。<br></packages...></file></packages...></file></p>
<p>看了如上介绍想必大家就清楚了，小明使用该条命令把女同事手机上的探探应用以及该应用的用户资料一并备份到了自己的电脑上。<br><br><strong>com.tantan.apk</strong>对就是这个文件，虽然这个问价是apk结尾的但他不是一个可安装的apk文件，我们不能直接去安装这个应用。在备份的时候我们可以给这个文件起任意的名字，放在任意的位置。我里没有指定目录，所以文件就保存在命令行当时所在的位置。D:</p>
<p>接下来，小明拿来了小杰的手机然后又敲了一条命令。</p>
<pre><code>adb restore com.tantan.apk
</code></pre><p>在小杰的手机上点了次确认，这样小杰的手机上就装了一个和女同事一样的探探</p>
<p><img src="http://olebohgyh.bkt.clouddn.com/17-2-16/31412667-file_1487232736235_d3a8.png" alt=""></p>
<p>然后他把女同事的暗恋对象设成了自己，把自己的暗恋对象设成了女同事</p>
<h2 id="唠叨"><a href="#唠叨" class="headerlink" title="唠叨"></a>唠叨</h2><p>还好这次的小杰是没有恶意的，不然就不好了……</p>
<p>试想一下，如果是的网盘或者是团购应用被别人取得的话，会发生什么。当然我没有去试太多应用是否存在这样的问题，XX网盘，XX哪，XX团购均还存在这样的问题。</p>
<p>确实这是一个很小的问题，但是它确实又是和我们相关很大的事情，信息安全关乎你我。</p>
<p><strong>最后申明下，我写下这篇文章没有什么恶意，只是想更多的开发者提高自己的开发意识，在应用上线时尽量关闭allowBackup，还有就是建议用户提高安全意识，手机加一个锁，如果手机加密的话那么刚才的故事就不会发生了。最后，关于为什么用探探举证例子，因为小杰真的在用探探啊</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信扫一扫揭秘]]></title>
      <url>http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要探索二维码的秘密之前，我们首先需要简单了解下什么是二维码。</p>
<h3 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h3><blockquote>
<p>二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。</p>
</blockquote>
<p>其实简单的说二维码就是一段简单的字符串图形化的展示，它可能是一个url，一段文字，或者是一首唐诗也不错哦<br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rxxbqqnsj207s07sgmr.jpg" alt="二维码1"><br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7rxyajt8nj207s07sjrt.jpg" alt="二维码2"><br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7rxz0bdixj207s07s75b.jpg" alt="二维码3"></p>
<h3 id="为什么要使用二维码"><a href="#为什么要使用二维码" class="headerlink" title="为什么要使用二维码"></a>为什么要使用二维码</h3><p>二维码的诞生可以说是真正的促进这移动互联网的发展。</p>
<ul>
<li>信息获取（名片、地图、WIFI密码、资料）</li>
<li>网站跳转（跳转到微博、手机网站、网站）</li>
<li>广告推送（用户扫码，直接浏览商家推送的视频、音频广告）</li>
<li>手机电商（用户扫码、手机直接购物下单）</li>
<li>防伪溯源（用户扫码、即可查看生产地；同时后台可以获取最终消费地)</li>
<li>优惠促销（用户扫码，下载电子优惠券，抽奖）</li>
<li>会员管理（用户手机上获取电子会员信息、VIP服务）</li>
<li>手机支付（扫描商品二维码，通过银行或第三方支付提供的手机端通道完成支付）</li>
</ul>
<p>在不同的领域，不同的行业二维码都可以用来简化原来的工作流程，那么我们为什么不来试试二维码呢？</p>
<h3 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h3><p>通过对上面的了解相信大家对二维码已经有了一定的了解，那么二维码是怎么生成的呢?</p>
<blockquote>
<p>维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x<br>25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)<em>4 + 21（V是版本号） 最高Version<br>40，(40-1)</em>4+21 = 177，所以最高是177 x 177 的正方形。      </p>
</blockquote>
<p><strong>二维码的基本结构如下：</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7rz07e9bhj20le0cuaax.jpg" alt=""></p>
<p>二维码一般由定位点图案、功能性数据、数据码和纠错码组成，生成的算法是固定的有需要的同学可以了解<br><a href="https://my.oschina.net/DeanCTO/blog/205677" title="二维码的生成原理" target="_blank" rel="external">二维码的生成原理</a>、<br><a href="http://blog.csdn.net/kelindame/article/details/45155185" title="二维码生成原理解析" target="_blank" rel="external">二维码生成原理解析</a><br>如今，基本上各个语言都有了比较好的二维码生成与解码的开源项目，有需要的同学可以自行google，本次我们呢不做具体介绍，因为不是重点啊 。</p>
<h2 id="微信二维码揭秘"><a href="#微信二维码揭秘" class="headerlink" title="微信二维码揭秘"></a>微信二维码揭秘</h2><h3 id="微信的二维码有哪些"><a href="#微信的二维码有哪些" class="headerlink" title="微信的二维码有哪些"></a>微信的二维码有哪些</h3><p>在平时的使用中我们可以发现微信在很多的场景中都有二维码的使用在，名片，联系人，支付等尤为明显，可以说二维码已经成为微信不可或缺的设计呢功能了。<br>那么微信的二维码到底有哪些是呢？</p>
<p><strong>以二维码扫描结果和功能区分</strong></p>
<ol>
<li>http(s)://www.<em>*</em>.com http链接</li>
<li>weixin://qr/××× 微信二维码</li>
<li><a href="http://weixin.qq.com/r/×××" target="_blank" rel="external">http://weixin.qq.com/r/×××</a> 微信二维码名片</li>
<li><a href="https://login.weixin.qq.com/l/×××" target="_blank" rel="external">https://login.weixin.qq.com/l/×××</a> 网页登陆二维码</li>
<li><a href="https://login.wechatapp.com/l/×××" target="_blank" rel="external">https://login.wechatapp.com/l/×××</a> 国际部网页登陆二维码</li>
<li>weixin://wxpay/bizpayurl/××× 微信支付</li>
<li><a href="http://weixin.qq.com/g/×××" target="_blank" rel="external">http://weixin.qq.com/g/×××</a> 微信群二维码</li>
</ol>
<p>其实在上面的二维码例子中大体上可以分为两类，1，4，5未一类，其他的为一类。第一类主要是普通类型和涉及登录相关的逻辑，第二类中的逻辑就是我们本次要谈论的逻辑。</p>
<p><strong>第二类流程如下：</strong><br><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rypqmgpjj20uk061js1.jpg" alt="流程图"></p>
<h3 id="实现微信二维码逻辑"><a href="#实现微信二维码逻辑" class="headerlink" title="实现微信二维码逻辑"></a>实现微信二维码逻辑</h3><p>由上面的介绍我们很清楚的知道，我们想要实现上面的功能我们生成的二维码肯定是一个url，然后对本本地是否安装有app的判断也是在服务端实现的（其实就是个js而已，不要怕），当然在客户端也需要对自己的代码做相应的配置。</p>
<h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><p>由于本人系Android开发工程师，对ios的了解也不是太多，所以本次配置主要是对android端而言的。<br>首先在manifest文件中配置扫描后需要跳转activity的intent-filter</p>
<p>还需要制定对应的host、pathPrefix、scheme<br>至于host、pathPrefix、scheme是什么，大家可以自己去google下，其实只要了解Url的组成原理就ok了。</p>
<pre><code>&lt;activity android:name=&quot;.otherTest.scan.FromUrlActicity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
            &lt;data
                android:host=&quot;www&quot;
                android:pathPrefix=&quot;/com/test&quot;
                android:scheme=&quot;flyou&quot; /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><p>上面的host和 pathPrefix是可以省略的，不过还是推荐大家都写上。<br>这样客户端的配置就完成了。        </p>
<h4 id="服务端解析"><a href="#服务端解析" class="headerlink" title="服务端解析"></a>服务端解析</h4><p>首先根据浏览器的userAgent判断来自哪个终端，如果是PC则直接跳转到下载页，如果是Android或者Ios则判断本地判断本地app书否存在如果存在则根据定义的scheme打开相应页面并传递数据，如果不存在该app则跳转到下载页面。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;我是一个测试页面&lt;/title&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=320.1, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;

&lt;script&gt;
/*获取自定义数据*/
function getQueryString(name) {  
    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);  
    var r = window.location.search.substr(1).match(reg);  
    if (r != null) return unescape(r[2]);  
    return null;  
}  
var userId=getQueryString(&quot;userId&quot;);
var u = navigator.userAgent || &apos;&apos;;
 /*首先判断是否是pc，若是pc访问则跳转到http://flyou.ren/ */
var isPC = !/(iphone|ios|android|mini|mobile|mobi|Nokia|Symbian|iPod|iPad|Windows\s+Phone|MQQBrowser|wp7|wp8|UCBrowser7|UCWEB|360\s+Aphone\s+Browser)/i.test(u);
var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //android终端或者uc浏览器
var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
if (isPC) { location.href = &quot;http://flyou.ren/&quot;; }
else if (isAndroid) {
    var the_href=&quot;http://flyou.ren/2016/09/13/%E5%BE%AE%E4%BF%A1%E6%89%AB%E4%B8%80%E6%89%AB%E6%8F%AD%E7%A7%98&quot;;//获得下载链接或在app下载页
    location.href=&quot;flyou://www/com/test?userId=&quot;+userId;//打开某手机上的某个app应用，并传递参数
    setTimeout(function(){
        window.location=the_href;//如果超时就跳转到app下载页，或者直接下载
    },2000);
}
else{
    //服务端可以根据ios 先关逻辑做相应的判断
    alert(&apos;宝宝暂时还不持支持IOS操作系统，宝宝会努力的&apos;)
}

&lt;/script&gt;


&lt;/head&gt;

&lt;/html&gt;
</code></pre><h4 id="服务端返回数据处理"><a href="#服务端返回数据处理" class="headerlink" title="服务端返回数据处理"></a>服务端返回数据处理</h4><p>在对应的Acticity里处理传递回来的参数，并做相应的处理，如微信名片二维码的功能，返回给相应页面用户id，当然这个用户的userId可以是经过加密的（别我问我怎么加密，你们这么加密我也不想知道）。</p>
<pre><code>public class FromUrlActicity extends AppCompatActivity {

private TextView tvUserid;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_qrcode_acticity);
    tvUserid = (TextView) findViewById(R.id.userid);
    Uri uriData = this.getIntent().getData();
    String userId = uriData.getQueryParameter(&quot;userId&quot;);

    tvUserid.setText(&quot;我是来自服务器的UserId:&quot;+userId);

    }
}
</code></pre><h4 id="扫描二维码"><a href="#扫描二维码" class="headerlink" title="扫描二维码"></a>扫描二维码</h4><p>自己或者使用第三方工具生成二维码如下</p>
<p><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s0hmygplj207s07s752.jpg" alt=""></p>
<p><strong>二维码对应字符串：http:\henu.flyou.ren/scan?userId=553274238</strong></p>
<p>在手机上使用浏览器扫一扫扫描二维码即可进入如下界面，并获得服务端传来的参数，完成相应的逻辑<br><img src="http://ww3.sinaimg.cn/large/a2f7c645jw1f7s01h4fndj20u00fwwfz.jpg" alt=""></p>
<p>当然，二维码可以向服务器传递多个数据，服务器也可以向客户端返回多个数据，分别定义获取即可。明白了上述的流程想要实现微信的上述流程也是很容易的。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，二维码的功能并不仅仅局限于上面的逻辑，二维码可以应用在多个行业和领域，那么快快发动你的才智来发现新的大陆吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于截图你所要了解的一切]]></title>
      <url>http://flyou.ren/2016/09/12/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%9B%BE%E4%BD%A0%E6%89%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E5%88%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着为什么要使用截图功能？</p>
<ul>
<li>更方便记录</li>
<li>更加便于分享</li>
<li>更加利于传输</li>
</ul>
<p>在android上有哪些截屏的方法呢？</p>
<ol>
<li>使用adb工具进行截图</li>
<li>使用android系统自带的截图</li>
<li>在自己的应用中实现截图操作</li>
</ol>
<p>今天，就对以上三种截图的方式进行下分析，写的不好的地方还请大家指正，共同进步。</p>
<p>##截图的实现</p>
<h3 id="1-使用adb命令截图"><a href="#1-使用adb命令截图" class="headerlink" title="1.使用adb命令截图"></a>1.使用adb命令截图</h3><p>系统是Android 2.3以上：</p>
<p><code>adb shell screencap -p xxx.png</code></p>
<p>系统是Android 4.0以上：</p>
<p><code>adb shell screenshot xxx.png</code></p>
<p>那么上面两个有什么区别呢？</p>
<p>screencap是从Android 2.3开始提供的一个系统级的截图工具，通过源码可以了解到screencap的实现方式，默认会从底层UI Surface去获取屏幕截图，如果失败则从linux kernel层的display framebuffer(/dev/graphics/fb0)去获取屏幕截图。</p>
<p>screenshot是从Android 4.0开始提供的另一个截图的工具， 通过源码可以发现screenshot则是直接读取/dev/graphics/fb0去获取屏幕的图像数据。</p>
<p>明白了这个，你就会清楚哪些电脑上的豌豆荚、腾讯手机管家等软件的屏幕截图功能是如何实现的了，其实就是调用这个这个api然后读取本地的图片而已。</p>
<pre><code>adb shell screencap -p /sdcard/flyou.png
adb pull /mnt/sdcard/output.png D:flyou.png
adb shell rm /sdcard/flyou.png
</code></pre><p>首先是调用系统截图命令将图片保存到sd卡下，然后调用adb pull将sd卡上的截图给拉出，最后删除本地文件。</p>
<p>需要注意的是，上面的命令在电脑上操作adb命令进行截图，手机是不需要root权限的，但是如果在手机上在手机上是需要的。</p>
<pre><code>public void shortScreen(String filepath){
Process process = null;
try{
process = Runtime.getRuntime().exec(&quot;su&quot;);
PrintStream outputStream = null;
try {
    outputStream = new PrintStream(new BufferedOutputStream(process.getOutputStream(), 8192));
    outputStream.println(&quot;screencap -p &quot; + filePath);
    outputStream.flush();
}catch(Exception e){
    Log.e(TAG, e);
} finally {
    if (outputStream != null) {
        outputStream.close();
    }
}
process.waitFor();
}catch(Exception e){
Log.e(TAG, e);
}finally {
if(process != null){
    process.destroy();
}
}
}
</code></pre><p>在手机端需要执行如上代码便可执行adb命令截图。<br><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f7qvwenwrkj20o50c2n04.jpg" alt=""></p>
<h3 id="2-使用android系统自带的截图"><a href="#2-使用android系统自带的截图" class="headerlink" title="2.使用android系统自带的截图"></a>2.使用android系统自带的截图</h3><p>在android系统中，大多数的截屏快捷键都是“音量-” 加上电源键实现的，当然也有一些特殊的机型是不一样的。</p>
<p>虽然，我们不能在开发中这个使用这个api，但是我们可以通过源码来看看它是如何是实现的。</p>
<p>Android源码中对按键的捕获位于文件PhoneWindowManager.java（alps\frameworks\base\policy\src\com\android\internal\policy\impl）中，这个类处理所有的键盘输入事件，其中函数interceptKeyBeforeQueueing（）会对常用的按键做特殊处理。以nexus5 和小米5为例，是同时按电源键和音量下键来截屏，那么在这个函数中我们会看到这么两段代码：</p>
<pre><code>.......
 case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE: {
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (isScreenOn &amp;&amp; !mVolumeDownKeyTriggered
                            &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                        mVolumeDownKeyTriggered = true;
                        mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
......

        case KeyEvent.KEYCODE_POWER: {
            result &amp;= ~ACTION_PASS_TO_USER;
            if (down) {
                if (isScreenOn &amp;&amp; !mPowerKeyTriggered
                        &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
                    mPowerKeyTriggered = true;
                    mPowerKeyTime = event.getDownTime();
                    interceptScreenshotChord();
                }
......

//以下代码是对按键处理的判断
 private void interceptScreenshotChord() {
    if (mVolumeDownKeyTriggered &amp;&amp; mPowerKeyTriggered &amp;&amp; !mVolumeUpKeyTriggered) {
        final long now = SystemClock.uptimeMillis();
        if (now &lt;= mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS
                &amp;&amp; now &lt;= mPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) {
            mVolumeDownKeyConsumedByScreenshotChord = true;
            cancelPendingPowerKeyAction();

            mHandler.postDelayed(mScreenshotChordLongPress,
                        ViewConfiguration.getGlobalActionKeyTimeout());
        }
    }
}
</code></pre><p>系统截图的实现：</p>
<pre><code>private final Runnable mScreenshotChordLongPress = new Runnable() {
    public void run() {
        takeScreenshot();
    }
};

//如下为takeScreenshot()的代码
private void takeScreenshot() {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;,
                &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw())
                        msg.arg1 = 1;
                    if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw())
                        msg.arg2 = 1;
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    }
                }
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {}
        };
        if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
</code></pre><p>可以看到这个函数使用AIDL绑定了service服务到”com.android.systemui.screenshot.TakeScreenshotService”，并处理子线程返回的截图结果。</p>
<p>PS：android系统内部真的有好多实现都是靠的handler和message</p>
<pre><code>public class TakeScreenshotService extends Service {
private static final String TAG = &quot;TakeScreenshotService&quot;;

private static GlobalScreenshot mScreenshot;

private Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case 1:
                final Messenger callback = msg.replyTo;
                if (mScreenshot == null) {
                    mScreenshot = new GlobalScreenshot(TakeScreenshotService.this);
                }
                mScreenshot.takeScreenshot(new Runnable() {
                    @Override public void run() {
                        Message reply = Message.obtain(null, 1);
                        try {
                            callback.send(reply);
                        } catch (RemoteException e) {
                        }
                    }
                }, msg.arg1 &gt; 0, msg.arg2 &gt; 0);
        }
    }
};

@Override
public IBinder onBind(Intent intent) {
    return new Messenger(mHandler).getBinder();
}
}
</code></pre><p>最终调用，takeScreenshot获取屏幕截图</p>
<pre><code>/**
 * Takes a screenshot of the current display and shows an animation.
 */
void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) {
    // We need to orient the screenshot correctly (and the Surface api seems to take screenshots
    // only in the natural orientation of the device :!)
    mDisplay.getRealMetrics(mDisplayMetrics);
    float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels};
    float degrees = getDegreesForRotation(mDisplay.getRotation());
    boolean requiresRotation = (degrees &gt; 0);
    if (requiresRotation) {
        // Get the dimensions of the device in its native orientation
        mDisplayMatrix.reset();
        mDisplayMatrix.preRotate(-degrees);
        mDisplayMatrix.mapPoints(dims);
        dims[0] = Math.abs(dims[0]);
        dims[1] = Math.abs(dims[1]);
    }

    // Take the screenshot
    mScreenBitmap = Surface.screenshot((int) dims[0], (int) dims[1]);
    if (mScreenBitmap == null) {
        notifyScreenshotError(mContext, mNotificationManager);
        finisher.run();
        return;
    }

    if (requiresRotation) {
        // Rotate the screenshot to the current orientation
        Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels,
                mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(ss);
        c.translate(ss.getWidth() / 2, ss.getHeight() / 2);
        c.rotate(degrees);
        c.translate(-dims[0] / 2, -dims[1] / 2);
        c.drawBitmap(mScreenBitmap, 0, 0, null);
        c.setBitmap(null);
        mScreenBitmap = ss;
    }

    // Optimizations
    mScreenBitmap.setHasAlpha(false);
    mScreenBitmap.prepareToDraw();

    // Start the post-screenshot animation
    startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,
            statusBarVisible, navBarVisible);
}
</code></pre><p>最终得到Surface.screenshot（）方法，该方法属于native 层的方法，我们已经无法对代码进行查看，但是通过该方法</p>
<pre><code>public static native Bitmap screenshot(int width, int height);
</code></pre><p>我们可以看出，底层实际上是接受了一个图片的宽高，最终给我们返回一个半成品的bitmap，然后在java层我们再对图片进行一系列的操作。</p>
<h3 id="3-在自己的应用中实现截图操作"><a href="#3-在自己的应用中实现截图操作" class="headerlink" title="3.在自己的应用中实现截图操作"></a>3.在自己的应用中实现截图操作</h3><p>上面说了好多应用之外截图方式的实现，那么如果我们想要在我们的app中实现截图功能，我们该如何实现呢？</p>
<pre><code>public class ScreenShot {   

// 获取指定Activity的截屏，保存到png文件   
private static Bitmap takeScreenShot(Activity activity，String fileName){   


//View是你需要截图的View   
View view = activity.getWindow().getDecorView();   
view.setDrawingCacheEnabled(true);   
view.buildDrawingCache();   
Bitmap b1 = view.getDrawingCache();  
view.destroyDrawingCache();   
savePic(b1,fileName)
}   


//保存到sdcard   
private static void savePic(Bitmap b,String strFileName){   
FileOutputStream fos = null;   
try {   
fos = new FileOutputStream(strFileName);   
if (null != fos)   
{   
b.compress(Bitmap.CompressFormat.PNG, 90, fos);   
fos.flush();   
fos.close();   
}   
} catch (FileNotFoundException e) {   
e.printStackTrace();   
} catch (IOException e) {   
e.printStackTrace();   
}   
}   
}  
</code></pre><p><strong>截图效果如下：</strong><br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxsmer3gj20u01hcjvv.jpg" alt=""></p>
<p>如果不想要状态栏只需要对获得bitmap进行操作，截去状态栏的高度即可</p>
<p><strong>相关代码如下：</strong></p>
<pre><code>//获取状态栏高度   
Rect frame = new Rect();   
activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);   
int statusBarHeight = frame.top;   
System.out.println(statusBarHeight);   

//获取屏幕长和高   
int width = activity.getWindowManager().getDefaultDisplay().getWidth();   
int height = activity.getWindowManager().getDefaultDisplay().getHeight();   


//去掉标题栏    
Bitmap newBitmap = Bitmap.createBitmap(b1, 0, statusBarHeight, width, height - statusBarHeight); 
</code></pre><p>这样就可以获取对应没有状态栏的图片。<br><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7qxz0kw8uj20u01f9430.jpg" alt=""><br>但是，这样往往不能满足我们在开发中的需求，往往在开发中产品会要求我们只截去内容部分的图片，那么这时我们该怎么做呢？</p>
<p>其实方法也是很多，比如对<strong>先截去屏幕，然后对制定区域进行裁剪</strong>，<strong>使用自定义控件</strong>，其实原理也很简单，先绘制背景在确定子View的位置，再回执子View即可。但是呢这里也有几个比较简单的方法，<strong>直接获取相应布局的父布局，然后调用相关方法进行截取并保存即可</strong>。</p>
<p>下面只给出第三种方式的实现方法，如果对上面两种实现方法感兴趣的话自己可以了解下。</p>
<pre><code>View view = findViewById(R.id.share_layout);
Bitmap bmp = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
view.draw(new Canvas(bmp));
</code></pre><p>此时取到的BitMap就是你的目标布局的图片，但是使用此方法必须在数据加载完毕后使用，不然获取的截图可能是空白的，还有bitmap使用完需要记得<strong>recycle</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/large/a2f7c645jw1f7rog43thzj20p011iad9.jpg" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实现屏幕截图的方法有很多，实现的方法也是多种多样的，希望大家根据自己的需要都能够找到适合自己的方法，如果写的有什么纰漏的地方，欢迎大家指正讨论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定下几个小目标]]></title>
      <url>http://flyou.ren/2016/09/05/%E5%AE%9A%E4%B8%8B%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://ww2.sinaimg.cn/large/a2f7c645jw1f7iqwwww7yj20h809kdgu.jpg" alt=""></p>
<p>转眼已经毕业整整三个月了，一直没有好好静下来写些东西了，最近看见朋友圈都在定目标，再加上今天有空所以就也写点东西吧。</p>
<h3 id="1-瘦下来"><a href="#1-瘦下来" class="headerlink" title="1.瘦下来"></a>1.瘦下来</h3><p>自己真的是越来越胖了，自己都受不了自己了，已经从以前的120飙升到了160，哦买噶，再不瘦我真的就要变成胖子了，我不要，我不要！！</p>
<p>从今天起，每天坚持锻炼，晚上少吃点可好？当然120不是我的目标体重，要不然又要被老妈催着增肥了！！那么就140吧？</p>
<h3 id="2-沉下去"><a href="#2-沉下去" class="headerlink" title="2.沉下去"></a>2.沉下去</h3><p>毕业是毕业了，但是我认为我们都不能因为自己角色的改变而去中断学习，学习应该是贯穿每个人一生的事情。我还是希望自己能够把自己定位为一个学生，对啊学生真好。</p>
<ul>
<li>在最近的一段时间尽量把java基础和数据库操作回顾一遍</li>
<li>学习前端以及node.js相关知识，如果可以的话尽量多看看PHP吧</li>
<li>掌握几门其他语言，python和lua等</li>
<li>至于android，我还是希望自己能多学习，多记录</li>
</ul>
<h3 id="3-来写作"><a href="#3-来写作" class="headerlink" title="3.来写作"></a>3.来写作</h3><p>写作可以让我们更加巩固自己的知识，是自己的知识体系更加的清晰并完善，只有不断的写作和记录自己才会知道自己还有那些不了解，自己还有那些需要去学习。</p>
<p>当然，我觉得我平时也不会仅仅去写些关于技术的相关的，我更会在自己的博客中分享自己的心得以及对某一件事的看法，因为写作也是使人放松的一种方法，那么我们为什么不坚持呢？</p>
<h3 id="4-去旅游"><a href="#4-去旅游" class="headerlink" title="4.去旅游"></a>4.去旅游</h3><p>2016年已经过去了一大半，说好的出玩计划因为各种原因都没有实现，最近心里也是有许多的额事情，感觉心得压力很大，真的觉得自己必须要出去转转了，至于目的地是哪，我觉得都是可以的，厦门？杭州？南京？或者是西藏吧。</p>
<p>一个人或者约三两个好友感觉去哪里都是不错的，是的，是时候出去转转了呢！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，我的小目标定好了，希望自己的目标能够在新年前实现吧，这样我才好写我的年终总结啊。</p>
<p>于：2016/9/5 15:59:15 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android夜间模式浅析]]></title>
      <url>http://flyou.ren/2016/08/18/android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="几种实现夜间模式的方式"><a href="#几种实现夜间模式的方式" class="headerlink" title="几种实现夜间模式的方式"></a>几种实现夜间模式的方式</h2><h3 id="1：修改theme，重启activity"><a href="#1：修改theme，重启activity" class="headerlink" title="1：修改theme，重启activity"></a>1：修改theme，重启activity</h3><p>使用时定义不同的主题，通过切换主题重启acticity的方式完成切换</p>
<p><strong>优点</strong>：正儿八经的夜间模式，配色看着舒服</p>
<p><strong>缺点</strong>：图片刺眼、闪屏</p>
<h3 id="2：覆盖一定透明度的View"><a href="#2：覆盖一定透明度的View" class="headerlink" title="2：覆盖一定透明度的View"></a>2：覆盖一定透明度的View</h3><p>使用一个带黑色带透明度的View，盖在现有的activity上，效果类似你带上墨镜，看着太阳不刺眼。</p>
<p><strong>优点</strong>：不用重启activity，不闪屏；加上透明度过渡动画，模式之间切换非常舒服，解决了1中，白底图片依旧刺眼的问题。</p>
<p><strong>缺点</strong>：配色没变化，就算带上墨镜，白天依旧是白天。</p>
<h3 id="3：使用动态换肤方案"><a href="#3：使用动态换肤方案" class="headerlink" title="3：使用动态换肤方案"></a>3：使用动态换肤方案</h3><p>一般借助于第三方库完成换肤，如：<br><a href="https://github.com/hongyangAndroid/ChangeSkin" target="_blank" rel="external">https://github.com/hongyangAndroid/ChangeSkin</a><br><a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">https://github.com/fengjundev/Android-Skin-Loader</a></p>
<p><strong>优点</strong>：不用重启activity，不闪屏；可以为程序提供多种皮肤方案不局限于夜间/白天模式。</p>
<p><strong>缺点</strong>：在制作方面代价过大，侵入性较强，需要以来第三方库完成，可靠性不能得到保证。</p>
<h3 id="4：使用-Support-Library-23-2-0-DayNight主题实现"><a href="#4：使用-Support-Library-23-2-0-DayNight主题实现" class="headerlink" title="4：使用 Support Library 23.2.0 DayNight主题实现"></a>4：使用 Support Library 23.2.0 DayNight主题实现</h3><p><strong>优点</strong>：Google自家产品，可靠性高，配置简单，省心省力，在仅仅需要实现夜间/日间模式的应用内强烈推荐。</p>
<p><strong>缺点</strong>：不支持多皮肤切换算吗？貌似今天只谈夜间模式的实现……。</p>
<h2 id="使用DayNight主题来实现夜间模式"><a href="#使用DayNight主题来实现夜间模式" class="headerlink" title="使用DayNight主题来实现夜间模式"></a>使用DayNight主题来实现夜间模式</h2><p>对于前两种方式来说，从实现来说是不困难的但是对用户的体验在一定程度上是很不好的，一个需要重启activity，一个配色无法改变都是我们不推荐的。</p>
<p>当然第三种方式市面上也有比较成熟的第三方库来完成程序的换肤，但是对于单单需要夜间模式的应用来说未免有些大材小用了。</p>
<p>今天我们使用DayNight主题来实现换肤功能。</p>
<h3 id="1-定义DayNight主题，及相关属性"><a href="#1-定义DayNight主题，及相关属性" class="headerlink" title="1.定义DayNight主题，及相关属性"></a>1.定义DayNight主题，及相关属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;</div><div class="line">      &lt;!-- Customize your theme here. --&gt;</div><div class="line">      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</div><div class="line">      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</div><div class="line"> 		&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>可以在主题中定义一些颜色尺寸等属性，在vlaues的colors.xml 声明color属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>在res下面创建values-night文件夹，创建colors.xml声明color属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">   &lt;color name=&quot;colorPrimary&quot;&gt;#1f2023&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorPrimaryDark&quot;&gt;#18181a&lt;/color&gt;</div><div class="line">   &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<h3 id="2-为程序设置初始模式"><a href="#2-为程序设置初始模式" class="headerlink" title="2.为程序设置初始模式"></a>2.为程序设置初始模式</h3><p>程序中进行主题的初始化。你需要调用 AppCompatDelegate.setDefaultNightMode() ，它有四个参数：</p>
<p>MODE_NIGHT_NO. 使用亮色（light）主题</p>
<p>MODE_NIGHT_YES. 使用暗色（dark）主题</p>
<p>MODE_NIGHT_AUTO. 根据当前时间自动切换 亮色（light）/暗色（dark）主题</p>
<p>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统，通常为 MODE_NIGHT_NO</p>
<p>如在Application中进行初始化：</p>
<pre><code>public class MyApplication extends Application {
static {
    AppCompatDelegate.setDefaultNightMode(
            AppCompatDelegate.MODE_NIGHT_NO);
}

@Override
public void onCreate() {
    super.onCreate();
}

}
</code></pre><h3 id="3-在初始化时就切换夜间模式"><a href="#3-在初始化时就切换夜间模式" class="headerlink" title="3.在初始化时就切换夜间模式"></a>3.在初始化时就切换夜间模式</h3><pre><code> public class MyActivity extends AppCompatActivity {
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (savedInstanceState == null) {
        // Set the local night mode to some value
        getDelegate().setLocalNightMode(
                AppCompatDelegate.MODE_NIGHT_...);
        // 调用 recreate() 使设置生效
        recreate();
    }
} }
</code></pre><h3 id="4-如何获取当前主题的状态"><a href="#4-如何获取当前主题的状态" class="headerlink" title="4.如何获取当前主题的状态"></a>4.如何获取当前主题的状态</h3><pre><code>int currentNightMode = getResources().getConfiguration().uiMode
    &amp; Configuration.UI_MODE_NIGHT_MASK;

case Configuration.UI_MODE_NIGHT_NO:

case Configuration.UI_MODE_NIGHT_YES:

case Configuration.UI_MODE_NIGHT_UNDEFINED:
</code></pre><p>可以通过上面面的几种状态来进行相应的操作如：<br>```<br> private void judeStatusOfDayNight() {</p>
<pre><code>    int currentNightMode = getResources().getConfiguration().uiMode
            &amp; Configuration.UI_MODE_NIGHT_MASK;
    switch (currentNightMode) {
        case Configuration.UI_MODE_NIGHT_NO:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_YES);


            break;
        case Configuration.UI_MODE_NIGHT_YES:
             getDelegate().setDefaultNightMode(
                AppCompatDelegate.MODE_NIGHT_NO);
            break;
        case Configuration.UI_MODE_NIGHT_UNDEFINED:
            getDelegate().setDefaultNightMode(
                    AppCompatDelegate.MODE_NIGHT_AUTO);
            break;
    }
    // 调用 recreate() 使设置生效
    recreate();
}
</code></pre><p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a2f7c645jw1f6y5w7d0npg20dc0m841f.gif" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，这仅仅是一个简单的例子，如果涉及图片你需要创建drawable-night文件夹。</p>
<p>对于一些按钮的颜色背景都需要做相应的处理，当然处理起来还是很简单的。</p>
<p>那么现在为你的程序加上夜间模式吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://flyou.ren/2016/08/11/Hello%20Hexo/</url>
      <content type="html"><![CDATA[<h2 id="我的Blog发展史"><a href="#我的Blog发展史" class="headerlink" title="我的Blog发展史"></a>我的Blog发展史</h2><p>从12年开始写博客到现在，自己也接触了很多的博客，比如博客园，CSDD等，再到后来自己又接触到了WordPress，在上面写了一段时间总体来说是不错的，但是相应速度总是觉得有点慢。<br>于是便有了现在的博客，相比于以前用过的Blog，给予node.js 使其的响应速度可以说是相当的快，再加上MarkDown语法的支持，使得用它写作简直爽到飞，好吧就从今天开始入手吧。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>处于便于查看的目的，下面的提示命令就不删除了，哈哈。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
